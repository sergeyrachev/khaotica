<html>

<head>
<title>Tracing</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="../css/txt.css" rel="stylesheet" type="text/css"/>
</head>


<body topmargin="20" leftmargin="5" bgcolor="white" link="red" alink="#003399" vlink="#003399">

<h3>6. Tracing</h3>

<p>
Printing information about a bitstream's content is extremely useful, particularly during development 
and debugging. Also, when two or more separate organizations are developing a specification and 
pursuing independent implementations, it is very important to have traces of the files generated by 
each tool for comparison and debugging purposes. One could of course insert verbatim 
<code>printf</code> statements for all parsable variables, but this can quickly get out of hand.
</p> 

<p>
The translator can automatically generate tracing code and insert it in the <code>get()</code> method
(using the <a href="options.htm">command line option</a> <code>-t</code>, or the 
<a href="pragma.htm">pragma directive</a> <code>trace</code>). This means that, without modifying your
program or Flavor source in any way, you can automatically create detailed traces of your files.
</p>

<p>
The tracing output is directed to the standard output. Note that the translator does not print out 
the trace directly. Instead, it calls a quite simple <code>trace</code> function which is part of the 
run-time library. This means that you can very easily use your own tracing functions to customize both
the output destination as well as formatting (more information is provided in the 
<a href="rtl.htm">Run-Time Library</a>). In the following we describe the trace output as provided by
the standard run-time library implementation.
</p>

<p>
Let's first define a complex representation that will excercise all of the tracing features.
</p>

<table border="0" width="100%" class="Example">
<caption>PolyTest.fl</caption>
<tr><td width="100%"><code>
<pre>class Base : unsigned int(2) id = 0 {
    bit(32) marker1 = 0xFFFF;
    bit(5) marker2 = 0b1010.1;
    unsigned int(4) length;
    char(8) data[length];
}

class Derived1 extends Base : unsigned int(2) id = 1 {
    int(8) d1 = '1';
}

class Derived2 extends Base : unsigned int(2) id = 2 {
    float(32) d2 = 2.1;
}

class PolyTest {
    Base b[3];
}</pre>
</code></td></tr>
</table>

<p>
The structure is as follows. Our <code>PolyTest</code> class contains three objects of type 
<code>Base</code>. The <code>Base</code> objects, in turn, are polymorphic; any one of the
three classes - <code>Base</code>, <code>Derived1</code>, or <code>Derived2</code> - can appear
in the place of <code>Base</code>.  The <code>Base</code> object is composed of two markers
having fixed values, followed by a length specification and a number of bytes equal to that 
length.  The <code>Derived1</code> and <code>Derived2</code> objects each add a fixed variable, 
either an integer or a float.
</p>

<p>
We created a <code>PolyTest</code> object where each of the three <code>Base</code> objects it contains 
is of type <code>Base</code>, <code>Derived1</code>, and <code>Derived2</code> respectively, in that 
order. The data contained in variable <code>data</code> of each class is the name of the class in 
ASCII. The following is trace produced by calling the <code>PolyTest.get()</code> method on that sample 
file.
</p>

<table border="0" width="100%" class="Example">
<caption>Automatically Generated Trace from PolyTest.fl</caption>
<tr><td width="100%"><code>
<pre>    At Bit  Size      Value Description
        0:                  begin PolyTest
        0:                  processing Base b[0]
        0:                  begin Base
        0:    2          00 id (0)
        2:   32 00 00 FF FF marker1 (65535)
       34:    5          15 marker2 (21)
       39:    4          04 length (4)
       43:    8          42 data[0] (B)
       51:    8          61 data[1] (a)
       59:    8          73 data[2] (s)
       67:    8          65 data[3] (e)
       75:                  end Base
       75:                  processing Base b[1]
       75:                  begin Derived1
       75:    2          01 id (1)
       77:                  begin Base
       77:   32 00 00 FF FF marker1 (65535)
      109:    5          15 marker2 (21)
      114:    4          08 length (8)
      118:    8          44 data[0] (D)
      126:    8          65 data[1] (e)
      134:    8          72 data[2] (r)
      142:    8          69 data[3] (i)
      150:    8          76 data[4] (v)
      158:    8          65 data[5] (e)
      166:    8          64 data[6] (d)
      174:    8          31 data[7] (1)
      182:                  end Base
      182:    8          31 d1 (49)
      190:                  end Derived1
      190:                  processing Base b[2]
      190:                  begin Derived2
      190:    2          02 id (2)
      192:                  begin Base
      192:   32 00 00 FF FF marker1 (65535)
      224:    5          15 marker2 (21)
      229:    4          08 length (8)
      233:    8          44 data[0] (D)
      241:    8          65 data[1] (e)
      249:    8          72 data[2] (r)
      257:    8          69 data[3] (i)
      265:    8          76 data[4] (v)
      273:    8          65 data[5] (e)
      281:    8          64 data[6] (d)
      289:    8          32 data[7] (2)
      297:                  end Base
      297:   32         2.1 d2 (2.1)
      329:                  end Derived2
      329:                  end PolyTest</pre>
</code></td></tr>
</table>

<p>
As you can see, the trace output includes in each line: the bit position (starting from the beginning
of the bitstream), the size of the quantity read, its value in hexadecimal (or floating point, if 
applicable), and a description. In some cases there is no length or value indication, meaning that no
variable was parsed.
</p>

<p>
The first line indicates "<code>begin PolyTest</code>", signalling the entry in the <code>get()</code>
method of <code>PolyTest</code>. For all classes, the beginning and end of the <code>get()</code> method
is signalled by "<code>begin</code>" and "<code>end</code>".  Then, we have the message 
"<code>processing Base b[0]</code>". This message is always printed before processing a variable of
type class (i.e., before calling its own <code>get()</code> method), so that it is clear which member
of the original class is being parsed. As you can see the "<code>processing Base b[0]</code>" message
is immediately followed by "<code>begin Base</code>", signalled by the entry to <code>Base::get()</code>. 
The trace then contains each of the variables of <code>Base</code>, including their hexadecimal (3rd 
column) and actual decimal value (in parentheses, in the description text).
</p>

<p>
Moving forward, at bit position 75 we have the beginning of the <code>Test.b[1]</code> class. As this
is actually a <code>Derived1</code> object, the <code>Derived1</code> <code>get()</code> function is 
called; as a result, the trace indicates <code>begin Derived1</code>. Note that the ID 
is actually parsed by the derived class. Immediately afterwards the <code>get()</code> method of the
<code>Base</code> class is called. When it ends, the <code>Derived1</code> <code>get()</code> continues
to parse the <code>d1</code> variable. The situation is repeated for <code>PolyTest.b[2]</code>, 
starting at bit 190. Notice that in bit position 297 where the <code>float</code> variable <code>d2</code> 
is traced, the "Value" column indicates the actual floating point value instead of the raw bits. The 
trace ends at the end of the <code>PolyTest.get()</code> method, which is signalled at bit 361 with 
the "<code>end Test</code>" message.
</p>

<p>
In this particular case no error was detected. Bitstream syntax errors occur when a parsable variable
has an expected value (e.g., the <code>marker1</code> variable or the object ID <code>id</code>). When
such an error is detected, the trace output will include the string "[ERROR]" in the end of the 
description.
</p>

<p>
Also, a descriptive message is printed when the ID lookup for polymorphic classes fails. For example, at bit 190, 
and after the '<code>processing Base b[1]</code>' message, if the ID didn't match any of 
<code>Base</code> or its derived classes the following message would be printed: "<code>ID b[1].id 
lookup failed</code>". In order to allow the code to continue, the base class type is used to create
the new object. To demonstrate error handling, we ran the program in an arbitrary binary file so that
it gets completely confused. Here is the output.
</p>

<table border="0" width="100%" class="Example">
<caption>Trace Output from PolyTest.fl on a Random Binary File</caption>
<tr><td width="100%"><code>
<pre>    At Bit  Size      Value Description
        0:                  begin PolyTest
        0:                  processing Base b[0]
        0:                  begin Base
        0:    2          00 id (0)
Const value mismatch for 'marker1'
        2:   32 BC A8 81 01 marker1 (-1129807615) [ERROR]
Const value mismatch for 'marker2'
       34:    5          13 marker2 (19) [ERROR]
       39:    4          03 length (3)
       43:    8          63 data[0] (c)
       51:    8          0B data[1] ()
       59:    8          B3 data[2] (?)
       67:                  end Base
       67:                  processing Base b[1]
       67:                  begin Derived1
       67:    2          01 id (1)
       69:                  begin Base
Const value mismatch for 'marker1'
       69:   32 EE 4C 61 A1 marker1 (-296984159) [ERROR]
Const value mismatch for 'marker2'
      101:    5          08 marker2 (8) [ERROR]
      106:    4          08 length (8)
      110:    8          0A data[0] ( )
      118:    8          83 data[1] (?)
      126:    8          42 data[2] (B)
      134:    8          88 data[3] (?)
      142:    8          0A data[4] ( )
      150:    8          88 data[5] (?)
      158:    8          14 data[6] (.)
      166:    8          1B data[7] (.)
      174:                  end Base
Const value mismatch for 'd1'
      174:    8          DB d1 (-37) [ERROR]
      182:                  end Derived1
      182:                  processing Base b[2]
      182:                  begin Base
      182:    2          00 id (0)
Const value mismatch for 'marker1'
      184:   32 79 54 65 73 marker1 (2035574131) [ERROR]
Const value mismatch for 'marker2'
      216:    5          0E marker2 (14) [ERROR]
      221:    4          08 length (8)
      225:    8          5C data[0] (\)
      233:    8          D4 data[1] (?)
      241:    8          C2 data[2] (?)
      249:    8          EC data[3] (?)
      257:    8          C2 data[4] (?)
      265:    8          1A data[5] (.)
      273:    8          14 data[6] (.)
      281:    8          40 data[7] (@)
      289:                  end Base
      289:                  end PolyTest
</pre></code></td></tr>
</table>

<p>
As we can see, almost all the markers are incorrect. The IDs, because of their short length (2 bits),
turn out to be correct.  If there were an invalid ID, then the generated code would use the base 
class <code>Base</code> in order to be able to continue.
</p>


<p>&nbsp;</p>
<p align="center" class="notice"><a href='..\copyright.htm'>Copyright Notice</a></p>
<p>&nbsp;</p>


</body>

</html>
