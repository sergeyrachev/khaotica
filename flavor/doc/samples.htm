<html>

<head>
<title>Samples</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="./css/txt.css" rel="stylesheet" type="text/css"/>
</head>


<body topmargin="20" leftmargin="5" bgcolor="white" link="red" alink="#003399" vlink="#003399">

<a name="top"></a>

<h1>Samples</h1>

<p>
The distribution includes a number of sample programs as examples of how to write Flavor source
files, and how to interface your C++ or Java code to the code generated by the translator.
</p>

<p>
<a href="#description">Description</a> | <a href="#build">Building the Samples</a>
</p>


<h2><a name="description">Description</a></h2>

<p>The following sample programs are provided.</p>

<dl> 
  <dt><strong><a name="basic">basic</a></strong></dt>
  <dd>This is a very simple example of an object (<code>Basic</code>) describing bitstreams that 
      start with a set of required characters ('B', 'A', 'S', 'I', 'C') and a required number (an 
	  unsigned integer with the value 0xFF0, represented using 13 bits).  Following the required
	  values is an arbitrary 8-bit value (<code>next_parse_len</code>) that determines the number 
	  of bits used to represent the subsequent value (<code>num2</code>); <code>num2</code> is
	  a signed integer in little-endian byte ordering, and it is 2-byte aligned -- the bits 
	  representing <code>num2</code> must start in 2-byte boundary in the bitstream.  Finally, 
	  depending on the value of <code>num2</code>, <code>num3</code> is represented with 8 or 16
	  bits.  The purpose of this example is to demonstrate the process of creating a Flavor object 
	  in C++ or Java, and calling its <code>put()</code> and <code>get()</code> methods.<br><br>
      
      The program accepts an optional bitstream file name as its single argument.  If no
      argument is specified, then the default name - <code>basic.bs</code> - is used. It will
      first output the Flavor object named <code>Basic</code> into the specified file, and then
      read it back in from the file.<br><br>
      
      Usage:<br><code>
      CPP: basic [bitstream file name]<br>
      Java: java basic.Main [bitstream file name]</code><br><br>
      
      To get a detailed information about the bits read from the specified file, just uncomment
      the statement - <code>// %pragma trace</code> - in the <code>Basic.fl</code> file and 
      recompile the sample code as instructed in the <a href="#build">Building the Samples</a>
      section.  This triggers tracing, and more information about this can be found in the 
      <a target="_top" href="manual/manual.htm">user's manual</a>.
  <dt>&nbsp;</dt>

  <dt><strong><a name="gifprint">gifprint</a></strong></dt>
  <dd>This example includes a Flavor description of the GIF87a file structure.  Note that only 
      the headers are included.  It also includes verbatim statements that will output the 
      information contained in the GIF87a headers.<br><br>
      
      The program accepts a GIF87a file name as its single argument. Printing of the header
      information is triggered by the verbatim statements inserted in the Flavor source code.
      <br><br>
    
      A sample GIF87a file is included (<code>low.gif</code> in the <code>samples\data</code>
      directory) for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: gifprint [GIF87a file name]<br>
      Java: java gifprint.Main [GIF87a file name]</code></dd>
  <dt>&nbsp;</dt>
 
  <dt><strong><a name="gif87a">gif87a</a></strong></dt>
  <dd>This is similar to the <code>gifprint</code> sample, but instead of relying on user code to produce
      the GIF87a file information, the automatic tracing facility of the translator is used.<br><br>
      
      The program accepts a GIF87a file name as its single argument.  Note that the trace output
      will be directed to <code>stdout</code>, and it may be very large (depending on the GIF
      file size).<br><br>
      
      A sample GIF87a file is included (<code>low.gif</code> in the <code>samples\data</code>
      directory) for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: gif87a [GIF87a file name]<br>
      Java: java gif87a.Main [GIF87a file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="polytest">polytest</a></strong></dt>
  <dd>This is an example that demonstrates polymorphic parsable classes.  It contains the code 
      identical to the example used in the Tracing section of the 
      <a target="_top" href="manual/manual.htm">user's manual</a>.<br><br>
      
      The program accepts an optional bitstream file name as its single argument. If no
      argument is specified, then the default name - <code>polytest.bs</code> - is used. It will
      first output the Flavor object, <code>PolyTest</code>, bitstream and then read it back
      in. The Flavor code activates automatic tracing so that the contents of the <code>
      PolyTest</code> object are printed. The trace output will be directed to 
      <code>stdout</code>.<br><br>
      
      Usage:<br><code>
      CPP: polytest [bitstream file name]<br>
      Java: java polytest.Main [bitstream file name]</code></dd>
  <dd>&nbsp;</dd>

  <dt><strong><a name="maptest">maptest</a></strong></dt>
  <dd>This is an example that demonstrates the capability of map.<br><br>
  
      The program accepts an optional bitstream file name as its single argument.  If no 
      argument is specified, then the default name - <code>maptest.bs</code> - is used. It will
      first output the Flavor object, <code>MapTest</code>, bitstream and then read it back in. 
      The Flavor code activates automatic tracing so that the contents of the 
      <code>MapTest</code> object are printed. The trace output will be directed to 
      <code>stdout</code>.<br><br>
      
      Usage:<br><code>
      CPP: maptest [bitstream file name]<br>
      Java: java maptest.Main [bitstream file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="audio">audio</a></strong></dt>
  <dd>This program reads audio files in several formats.  Run the "<code>audio -h</code>" command
      and the supported formats are listed.  Also, if the "<code>--</code>" option is used, then
      the program automatically determines the file format by looking at the magic numbers.  
      The first four bytes are observed and if they correspond to:<br>
      ".snd" --> the NeXT/Sun audio format is assumed.<br>
      "FORM" --> the AIFF/AIFC audio format is assumed.<br>
      "RIFF" --> the RIFF WAV audio format is assumed.<br>
      otherwise --> 8 bit raw audio format is assumed.<br><br>
    
      Audio sample files are included (<code>test.xxx</code> in the <code>samples\data</code>
      directory) for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: audio -- [audio file name]<br>
      Java: java audio.Main -- [audio file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="mpeg1ss">mpeg1ss</a></strong></dt>
  <dd>This program parses MPEG-1 Systems files.<br><br>
    
      A sample MPEG-1 Systems file (<code>bu.mpg</code>) is included in the <code>samples\data</code>
      directory for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: mpeg1ss [MPEG-1 systems file name]<br>
      Java: java mpeg1ss.Main [MPEG-1 systems file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="mpeg1vs">mpeg1vs</a></strong></dt>
  <dd>This program parses MPEG-1 Video files.<br><br>
    
      A sample MPEG-1 Video file (<code>susie.mpv</code>) is included in the <code>samples\data</code>
      directory for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: mpeg1vs [MPEG-1 video file name]<br>
      Java: java mpeg1vs.Main [MPEG-1 video file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="mpeg1as">mpeg1as</a></strong></dt>
  <dd>This program parses MPEG-1 Audio files (Layers I, II, and III).  This example uses a new
      run-time library (incorporating the <code>BuffBitstream</code> class) to meet the 
      requirements of the MP3 specification.<br><br>
    
      A set of sample MPEG-1 Audio files (<code>layer1.mp1</code>,<code>layer2.mp2</code>, and 
      <code>layer3.mp3</code>) are included in the <code>samples\data</code>
      directory for testing purposes.<br><br>  

      Usage:<br><code>
      CPP: mpeg1as [MPEG-1 audio file name]<br>
      Java: java mpeg1as.Main [MPEG-1 audio file name]</code></dd>
  <dt>&nbsp;</dt>

  <dt><strong><a name="xml">XML samples</a></strong></dt>
  <dd>The <code>samples\xml\cpp</code> directory (and the <code>samples\xml\java</code> directory
      for Java) includes 4 samples (<code>basic</code> , <code>gif87a</code> , <code>
      polytest</code>, and <code>maptest</code>) for demonstrating the use of XML features.
      These samples show how the <code>putxml()</code> method can be used to generate
      XML documents.<br><br>
      
      Note that the <code>samples\xml\bin</code> directory already includes all the sample 
      executables (both for C++ and Java), and whenever the samples are compiled, the new
      executables are automatically copied to the <code>samples\xml\bin</code> directory.
      We describe how to build the samples in the section <a href="#build">below</a>.<br><br>

      Each project directory includes a <code>batch</code> directory consisting of five <code>
      .bat</code> files: <code>xml1.bat</code>, <code>xml2.bat</code>, <code>schema.bat</code>, 
      <code>bitgen1.bat</code>, and <code>bitgen2.bat</code>.  The first two files generate 
      XML documents from bitstreams by using the programs in the <code>samples\xml\bin</code> 
      directory, which convert the bitstreams in the <code>samples\data</code> directory.  The 
      <code>schema.bat</code> batch file is used to generate an XML schema from a Flavor 
      source file, and lastly, the last two batch files use <code>bitgen</code> to generate
      bitstreams corresponding to the documents.</dd>
  <dt>&nbsp;</dt>
</dl>

<p><a href="#top">Top</a></p>
<p>&nbsp;</p>


<h2><a name="build">Building the Samples</a></h2>


<h4>Win32 Platform</h4>

<p><strong>C++ Samples</strong></p>

<p>
We assume that you use the Microsoft Developer Studio environment (Version 6.0).  Load the 
<code>flavor.dsw</code> workspace in the <code>samples\cpp</code> directory.  The workspace 
contains all the samples described above (excluding the XML samples) and corresponding Flavor 
source files (<code>.fl</code>).  Select "<code>Win32 - Debug</code>" (or "<code>Win 32 - 
Release</code>") as the active project configuration (Debug is the default) and then build the 
project.  The executable for each sample will be placed in the <code>Debug</code> (or 
<code>Release</code>) subdirectory of the sample's directory. The project files are set up so
that you can run the examples directly from the Developer Studio environment.
</p>

<p><strong>Java Samples</strong></p>

<p>
In order to build Java sample code, you need to set the "FLAVOR_HOME" environment variable 
to the Flavor main installation directory.  After setting the variable, you can build all 
samples by invoking the <code>buildall.bat</code> batch file located in the <code>
samples\java</code> directory.  In order to build each sample separately, you can use the
<code>build.bat</code> batch file in each sample directory.  To execute samples, just invoke 
the <code>run.bat</code> batch file.
</p>

<p><strong>XML Samples</strong></p>

<p>
In case of C++, the projects corresponding to the XML samples described above are 
grouped into a single workspace <code>xml.dsw</code> (in <code>samples\xml\cpp</code>), and 
Microsoft Developer Studio can be used to open the workspace.  All settings are appropriately
set, and the executables can be straightforwardly built.  In case of Java, each sample 
includes a batch file (<code>build.bat</code>), which can be used to re-compile the executables.  
</p>

<p>
Note that the <code>samples\xml\bin</code> directory already includes all the sample 
executables (both for C++ and Java), and whenever the samples are compiled, the new
executables are copied to the <code>samples\xml\bin</code> directory.  
</p>
 

<h4>UNIX/Linux Platform</h4>

<p>
For UNIX/Linux platforms, the <code>configure</code> script, which automatically detects your
development environment and sets up <code>Makefile</code>s, can be used. After running 
<code>configure</code> you can build both C++ and Java samples using the <code>make</code> 
utility. Each <code>Makefile</code> can be customized by modifing the provided 
<code>Makefile.in</code> files.  For Java samples, the <code>CLASSPATH</code> environment 
variable should point to the Flavor library directory - <code>(Flavor main direcotry)\lib\java</code>.
All <code>Makefiles</code> are configured so that the samples can be compiled with a single
command -- <code>make</code>.
</p>


<p><a href="#top">Top</a></p>
<p>&nbsp;</p>

<p align="center" class="notice"><a href='copyright.htm'>Copyright Notice</a></p>
<p>&nbsp;</p>

</body>

</html>
