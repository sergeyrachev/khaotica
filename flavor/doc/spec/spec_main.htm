<html>

<head>
<title>Flavor Specification</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="../css/txt.css" rel="stylesheet" type="text/css"/>
</head>


<body topmargin="20" leftmargin="5" bgcolor="white" link="#003399" alink="#FF9900" vlink="#003399">

<p><strong>March 10, 2005</strong></p>

<p>
Flavor was designed to be an intuitive and natural extension of the typing system of object-oriented 
languages like C++ and Java.  This means that the bitstream representation information is placed together 
with the data declarations in a single place.  In C++ and Java, this place is where a class is defined.
</p>

<p>
Flavor has been explicitly designed to follow a declarative approach to bitstream syntax specification. 
In other words, the designer specifies how the data is laid out in the bitstream, and does not detail a 
step-by-step procedure that parses it.  This latter procedural approach would severely limit both the 
expressive power as well as the capability for automated processing and optimization, as it would eliminate 
the necessary level of abstraction.  As a result of this declarative approach, Flavor does not have 
functions or methods.
</p>

<p>
An additional feature of combining type declaration and bitstream representation is that the underlying 
object hierarchy of the base programming language (C++ or Java), becomes quite naturally the object 
hierarchy for bitstream representation purposes as well.  This is an important benefit for ease of 
application development, and it also allows Flavor to have a very rich typing system itself.
</p>

<p>
In general, Flavor follows the syntax rules of C++ and Java.  You can safely assume that all C++ and Java 
features are at your disposal.  When C++ and Java differ, the most restrictive rule between the two languages 
applies.
</p>

<p>
However, the following should be kept in mind.  Flavor is used to declare parsable variables in the right 
order and with the right parse size, as this is what defines the bitstream syntax.  As a result, regular 
statements (<code>if</code>, <code>for</code>, <code>while</code>, etc.) appear together with variable 
declarations.  Also, Flavor does not support structures, enumerations, pointers, references, casts, the 
<code>sizeof()</code> operator, and does not use the C++ preprocessor.
</p>

<p>
The specification has the following sections.  When applicable, at the top of a section we include a table
with the syntax summary.
</p>

<dl>
  <dt><a href="general.htm"><strong>Section 1: General</strong></a></dt>
  <dd>	<a href="general.htm#literals">1.1 Literals</a><br>
		<a href="general.htm#comments">1.2 Comments</a><br>
    	<a href="general.htm#names">1.3 Names</a><br>
    	<a href="general.htm#types">1.4 Built-In Types</a><br>
    	<a href="general.htm#usertype">1.5 User-Defined Types</a>
  </dd>
  <dt>&nbsp;</dt>
  
  <dt><a href="decl.htm"><strong>Section 2: Declarations</strong></a></dt>
  <dd>	<a href="decl.htm#general">2.1 General</a><br>
    	<a href="decl.htm#parsable">2.2 Parsable Variables</a><br>
  		<a href="decl.htm#lookahead">2.3 Look-Ahead Parsing</a><br>
    	<a href="decl.htm#expected">2.4 Parsable Variables with Expected Values</a>
  </dd>
  <dt>&nbsp;</dt>
  
  <dt><a href="arrays.htm"><strong>Section 3: Arrays and Partial Arrays</strong></a></dt>
  <dd>	<a href="arrays.htm#regular">3.1 Regular</a><br>
  		<a href="arrays.htm#partial">3.2 Partial Arrays</a><br>
  		<a href="arrays.htm#strings">3.3 Strings</a>
  </dd>
  <dt>&nbsp;</dt>
  
  <dt><a href="exp.htm"><strong>Section 4: Expressions and Statements</strong></a></dt>
  <dt>&nbsp;</dt>
  
  <dt><a href="classes.htm"><strong>Section 5: Classes</strong></a></dt>
  <dd>	<a href="classes.htm#general">5.1 General</a><br>
    	<a href="classes.htm#forward">5.2 Forward/Recursive Declarations</a><br>
      	<a href="classes.htm#parameter">5.3 Parameter Types</a><br>
    	<a href="classes.htm#inheritance">5.4 Inheritance</a><br>
    	<a href="classes.htm#polymorphic">5.5 Polymorphic Parsable Classes</a><br>
    	<a href="classes.htm#abstract">5.6 Abstract Classes</a>
  </dd>
  <dt>&nbsp;</dt>
  
  <dt><a href="scoping.htm"><strong>Section 6: Scoping Rules</strong></a></dt>
  <dt>&nbsp;</dt>
  
  <dt><a href="maps.htm"><strong>Section 7: Maps</strong></a></dt>
  <dd>	<a href="maps.htm#simple">7.1 Simple Maps</a><br>
    	<a href="maps.htm#extended">7.2 Extended Maps</a>
  </dd>
  <dt>&nbsp;</dt>
  
  <dt><a href="bacs.htm"><strong>Section 8: Binary Arithmetic Coders (BACs)</strong></a></dt>
  <dd>	<a href="bacs.htm#ibac">8.1 Integer BACs</a><br>
    	<a href="bacs.htm#fbac">8.2 Fast BACs</a>
  </dd>
  <dt>&nbsp;</dt>

  <dt><a href="operators.htm"><strong>Section 9: Built-In Operators</strong></a></dt>
  <dd>	<a href="operators.htm#lengthof">9.1 lengthof()</a><br>
    	<a href="operators.htm#isidof">9.2 isidof()</a><br>
    	<a href="operators.htm#skipbits">9.3 skipbits()</a><br>
    	<a href="operators.htm#nextbits">9.4 nextbits()</a><br>
    	<a href="operators.htm#nextcode">9.5 nextcode()</a><br>
    	<a href="operators.htm#numbits">9.6 numbits()</a><br>
  </dd>
  <dt>&nbsp;</dt>
</dl>

<p>
Should you find any problems with this document, we would appreciate your 
<a href="mailto:danny@ee.columbia.edu">feedback</a>.
</p>


<p align="center" class="notice"><a href='..\copyright.htm'>Copyright Notice</a></p>
<p>&nbsp;</p>


</body>

</html>
