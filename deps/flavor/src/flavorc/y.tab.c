/* yacc -l -P etc\yyparse.c -D y.tab.h -o y.tab.c D:\flavor\src\flavorc\parser.y */
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#endif
/*
 * Portable way of defining ANSI C prototypes
 */
#ifndef YY_ARGS
#if __STDC__
#define YY_ARGS(x)	x
#else
#define YY_ARGS(x)	()
#endif
#endif

#ifdef YACC_WINDOWS

#include <windows.h>

/*
 * the following is the handle to the current
 * instance of a windows program. The user
 * program calling yyparse must supply this!
 */

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;

#endif



/*
 * Copyright (c) 1997-2005 Alexandros Eleftheriadis, Danny Hong and 
 * Yuntai Kyong.
 *
 * This file is part of Flavor, developed at Columbia University
 * (http://flavor.sourceforge.net).
 *
 * Flavor is free software; you can redistribute it and/or modify
 * it under the terms of the Flavor Artistic License as described in
 * the file COPYING.txt. 
 *
 */

/*
 * Authors:
 * Alexandros Eleftheriadis <eleft@ee.columbia.edu>
 * Danny Hong <danny@ee.columbia.edu>
 * Yuntai Kyong <yuntaikyong@ieee.org>
 *
 */

/*
 *  Yacc parser for Flavor translator
 */

#include <stdio.h>
#include <string.h>

#include "port.h"
#include "error.h"
#include "globals.h"
#include "symbol.h"
#include "ptree.h"
#include "check.h"
#include "util.h"
#include "eval.h"
#include "compile.h"
#include "carray.h"

/* defined in the lexical analyzer */
void yyerror(char *fmt, ...);
int yywrap();
int include(char *file, int import);

/* Disable 'unreferenced label' warning from Microsoft Visual C++.
 * MKS Yacc generates various labels that are not used.
 */
#if defined(_WIN32_) || defined(WIN32)
#pragma warning(disable : 4102)
#endif

typedef union {
    char            *string;
    int             ival;
    double          dval;
    unsigned int    uival;
    bit_t           *bit;
    list_t          *lp;
    symbol_t        *sp;
    node_t          *np;
    verbatim_t	    *vp;
} YYSTYPE;
#define CHAR	257
#define BIT	258
#define INT	259
#define FLOAT	260
#define DOUBLE	261
#define CLASS	262
#define IF	263
#define ELSE	264
#define DO	265
#define WHILE	266
#define FOR	267
#define GOTO	268
#define BREAK	269
#define CONTINUE	270
#define REPEAT	271
#define MAP	272
#define EXTENDS	273
#define SWITCH	274
#define CASE	275
#define DEFAULT	276
#define BAC	277
#define PRAGMA	278
#define PRAGMA_ARRAY	279
#define PRAGMA_GET	280
#define PRAGMA_NOGET	281
#define PRAGMA_PUT	282
#define PRAGMA_NOPUT	283
#define PRAGMA_PUTXML	284
#define PRAGMA_NOPUTXML	285
#define PRAGMA_TRACE	286
#define PRAGMA_NOTRACE	287
#define PRAGMA_LINE	288
#define PRAGMA_NOLINE	289
#define PRAGMA_INCLUDES	290
#define PRAGMA_NULLSTRINGS	291
#define PRAGMA_NONULLSTRINGS	292
#define PRAGMA_NOINCLUDES	293
#define PRAGMA_BITSTREAM	294
#define PRAGMA_PREFIX	295
#define PRAGMA_ERROR_FUNC	296
#define PRAGMA_TRACE_FUNC	297
#define BAC_PREC	298
#define BAC_OOC	299
#define BAC_SOC	300
#define BAC_TE	301
#define BAC_RENORM	302
#define BAC_BS	303
#define BAC_INIT	304
#define BAC_END	305
#define BAC_RTABLE	306
#define BAC_NEXTI	307
#define BAC_TRANS	308
#define BAC_EXCH	309
#define INCLUDE	310
#define IMPORT	311
#define UNSIGNED	312
#define SIGNED	313
#define SHORT	314
#define LONG	315
#define CONST	316
#define ALIGNED	317
#define STATIC	318
#define ABSTRACT	319
#define LITTLE	320
#define BIG	321
#define INT_LITERAL	322
#define DOUBLE_LITERAL	323
#define BIT_LITERAL	324
#define STRING_LITERAL	325
#define VARIABLE	326
#define CLASS_TYPE	327
#define MAP_TYPE	328
#define BAC_TYPE	329
#define LABEL	330
#define LS	331
#define RS	332
#define GE	333
#define LE	334
#define NE	335
#define EQ	336
#define OR	337
#define AND	338
#define INC	339
#define DEC	340
#define RANGE	341
#define CLCL	342
#define MUL_ASSIGN	343
#define DIV_ASSIGN	344
#define MOD_ASSIGN	345
#define ADD_ASSIGN	346
#define SUB_ASSIGN	347
#define LS_ASSIGN	348
#define RS_ASSIGN	349
#define AND_ASSIGN	350
#define XOR_ASSIGN	351
#define OR_ASSIGN	352
#define DBL_BRACE_L	353
#define DBL_BRACE_R	354
#define DECL	355
#define EXPR	356
#define VERBATIM	357
#define VERBATIM_GET	358
#define VERBATIM_PUT	359
#define VERBATIM_BOTH	360
#define VERBATIM_C	361
#define VERBATIM_C_CPP	362
#define VERBATIM_GET_C	363
#define VERBATIM_PUT_C	364
#define VERBATIM_BOTH_C	365
#define VERBATIM_J	366
#define VERBATIM_GET_J	367
#define VERBATIM_PUT_J	368
#define VERBATIM_BOTH_J	369
#define LENGTHOF	370
#define ISIDOF	371
#define SKIPBITS	372
#define NEXTBITS	373
#define SNEXTBITS	374
#define LITTLE_NEXTBITS	375
#define LITTLE_SNEXTBITS	376
#define NEXTCODE	377
#define NUMBITS	378
#define ESC_FTYPE	379
#define ESC_MAP	380
#define ARRAY	381
#define LOWER_THAN_ELSE	382
extern int yychar, yyerrflag;
extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_sp, YY_t_ival, YY_t_lp, YY_t_dval, YY_t_bit, YY_t_string, YY_t_vp, YY_t_np
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %62 &000",  0},
	{ "%03: %61",  8},
	{ "%03: &067",  8},
	{ "%03: &068",  8},
	{ "%03: &069",  8},
	{ "%03: &080 %17 &081",  8},
	{ "%61: &071",  1},
	{ "%04: %03",  8},
	{ "%04: %04 &094 %17 &095",  8},
	{ "%04: %05 %61",  8},
	{ "%04: %04 &107",  8},
	{ "%04: %04 &108",  8},
	{ "%05: %04 &096",  8},
	{ "%06: %07",  8},
	{ "%06: %04",  8},
	{ "%06: %09 %06",  8},
	{ "%07: &139 &080 %04 &081",  8},
	{ "%07: &140 &080 &072 &077 %17 &081",  8},
	{ "%07: &141 &080 %17 &081",  8},
	{ "%07: %08",  8},
	{ "%07: &146 &080 &069 &081",  8},
	{ "%07: &146 &080 %32 &077 &069 &081",  8},
	{ "%07: &147 &080 &081",  8},
	{ "%08: &142 &080 %17 &081",  8},
	{ "%08: &142 &080 %31 &077 %17 &081",  8},
	{ "%08: &142 &080 %32 &077 %17 &081",  8},
	{ "%08: &142 &080 %32 &077 %31 &077 %17 &081",  8},
	{ "%31: %30",  2},
	{ "%31: %31 &077 %30",  2},
	{ "%09: &107",  2},
	{ "%09: &108",  2},
	{ "%09: &084",  2},
	{ "%09: &085",  2},
	{ "%09: &097",  2},
	{ "%09: &098",  2},
	{ "%10: %06",  8},
	{ "%10: %10 &086 %06",  8},
	{ "%10: %10 &087 %06",  8},
	{ "%10: %10 &093 %06",  8},
	{ "%11: %10",  8},
	{ "%11: %11 &084 %10",  8},
	{ "%11: %11 &085 %10",  8},
	{ "%12: %11",  8},
	{ "%12: %12 &099 %11",  8},
	{ "%12: %12 &100 %11",  8},
	{ "%12: %12 &091 %11",  8},
	{ "%12: %12 &092 %11",  8},
	{ "%12: %12 &090 %11",  8},
	{ "%13: %12",  8},
	{ "%13: %13 &088 %12",  8},
	{ "%13: %13 &089 %12",  8},
	{ "%13: %13 &102 %12",  8},
	{ "%13: %13 &101 %12",  8},
	{ "%13: %13 &104 %12",  8},
	{ "%13: %13 &103 %12",  8},
	{ "%14: %13",  8},
	{ "%14: %14 &106 %13",  8},
	{ "%15: %14",  8},
	{ "%15: %15 &105 %14",  8},
	{ "%16: %15",  8},
	{ "%16: %15 &078 %16 &079 %16",  8},
	{ "%17: %16",  8},
	{ "%17: %06 %20 %17",  8},
	{ "%20: &111",  2},
	{ "%20: &112",  2},
	{ "%20: &113",  2},
	{ "%20: &114",  2},
	{ "%20: &115",  2},
	{ "%20: &116",  2},
	{ "%20: &117",  2},
	{ "%20: &118",  2},
	{ "%20: &119",  2},
	{ "%20: &120",  2},
	{ "%20: &121",  2},
	{ "%18: %17",  8},
	{ "%18: %18 &077 %17",  8},
	{ "%19: %17",  8},
	{ "%19: %17 &077 %19",  8},
	{ "%24: %25 &076",  3},
	{ "%25: %26 %36",  3},
	{ "%25: %25 &077 %36",  3},
	{ "%26: %32 %27",  3},
	{ "%26: %32 %28",  3},
	{ "%27: %33",  3},
	{ "%27: %29",  3},
	{ "%27: %29 %33",  3},
	{ "%28: %35 &080 %16 &081",  3},
	{ "%28: %35 &080 &073 &081",  3},
	{ "%28: %34 &080 &073 &081",  3},
	{ "%28: %35 &080 %16 &081 &086",  3},
	{ "%28: %35 &080 &073 &081 &086",  3},
	{ "%28: %34 &080 &073 &081 &086",  3},
	{ "%28: %29 &080 %16 &081",  3},
	{ "%28: %29 &080 &073 &081",  3},
	{ "%28: %29 &080 %16 &081 &086",  3},
	{ "%28: %29 &080 &073 &081 &086",  3},
	{ "%28: %29 %35 &080 %16 &081",  3},
	{ "%28: %29 %35 &080 &073 &081",  3},
	{ "%28: %29 %35 &080 %16 &081 &086",  3},
	{ "%28: %29 %35 &080 &073 &081 &086",  3},
	{ "%28: %35 &080 &074 &081",  3},
	{ "%29: %30",  2},
	{ "%29: %29 %30",  2},
	{ "%30: &057",  2},
	{ "%30: &058",  2},
	{ "%30: &059",  2},
	{ "%30: &060",  2},
	{ "%30: &061",  2},
	{ "%30: &065",  2},
	{ "%30: &066",  2},
	{ "%32:",  8},
	{ "%32: &062",  8},
	{ "%32: &062 &080 %16 &081",  8},
	{ "%33: %35",  1},
	{ "%33: %34",  1},
	{ "%35: &003",  1},
	{ "%35: &002",  1},
	{ "%35: &004",  1},
	{ "%35: &005",  1},
	{ "%35: &006",  1},
	{ "%34: &072",  1},
	{ "%36: %37",  3},
	{ "%36: %37 &111 %17",  3},
	{ "%36: %37 &111 %21",  3},
	{ "%36: %38",  3},
	{ "%36: %39",  3},
	{ "%21: &082 %23 &083",  8},
	{ "%21: &070",  8},
	{ "%23: %22",  8},
	{ "%23: %23 &077 %22",  8},
	{ "%22: %17",  8},
	{ "%22: %21",  8},
	{ "%37: %61",  3},
	{ "%37: %37 &094 %17 &095",  3},
	{ "%37: %37 &094 &094 %17 &095 &095",  3},
	{ "%38: %37 &080 %19 &081",  3},
	{ "%39: %37 &111 %16 &109 %16",  3},
	{ "%40: %41",  3},
	{ "%40: %42",  3},
	{ "%40: %45",  3},
	{ "%40: %46",  3},
	{ "%40: %47",  3},
	{ "%40: %48",  3},
	{ "%40: %49",  3},
	{ "%41: %61 &079 %44",  3},
	{ "%41: &020 %16 &079 %44",  3},
	{ "%41: &021 &079 %44",  3},
	{ "%42: &082 &083",  3},
	{ "%42: &082 %43 &083",  3},
	{ "%43: %44",  3},
	{ "%43: %43 %44",  3},
	{ "%44: %40",  3},
	{ "%44: %24",  3},
	{ "%44: %82",  3},
	{ "%44: %83",  3},
	{ "%44: %01",  3},
	{ "%44: %02",  3},
	{ "%45: &076",  3},
	{ "%45: %17 &076",  3},
	{ "%46: &008 &080 %15 &081 %44",  3},
	{ "%46: &008 &080 %15 &081 %44 &009 %44",  3},
	{ "%46: &019 &080 %17 &081 %44",  3},
	{ "%47: &011 &080 %15 &081 %44",  3},
	{ "%47: &010 %44 &011 &080 %15 &081 &076",  3},
	{ "%47: &012 &080 &076 &076 &081 %44",  3},
	{ "%47: &012 &080 &076 &076 %18 &081 %44",  3},
	{ "%47: &012 &080 &076 %15 &076 &081 %44",  3},
	{ "%47: &012 &080 &076 %15 &076 %18 &081 %44",  3},
	{ "%47: &012 &080 %18 &076 &076 &081 %44",  3},
	{ "%47: &012 &080 %18 &076 &076 %18 &081 %44",  3},
	{ "%47: &012 &080 %18 &076 %15 &076 &081 %44",  3},
	{ "%47: &012 &080 %18 &076 %15 &076 %18 &081 %44",  3},
	{ "%48: &013 &075 &076",  3},
	{ "%48: &015 &076",  3},
	{ "%48: &014 &076",  3},
	{ "%62: %63",  3},
	{ "%62: %62 %63",  3},
	{ "%63: %24",  3},
	{ "%63: %50",  3},
	{ "%63: %64",  3},
	{ "%63: %82",  3},
	{ "%63: %83",  3},
	{ "%63: %01",  3},
	{ "%63: %02",  3},
	{ "%63: %74",  3},
	{ "%50: %51 %58",  3},
	{ "%50: %51 &076",  3},
	{ "%51: %52",  1},
	{ "%51: %52 &079 %56",  1},
	{ "%51: %52 &079 %57",  1},
	{ "%52: %53",  1},
	{ "%52: %53 &018 &072",  1},
	{ "%52: %53 &018 %61",  1},
	{ "%53: %54",  1},
	{ "%53: %54 &080 %59 &081",  1},
	{ "%54: %32 %55",  1},
	{ "%55: &007 %61",  1},
	{ "%55: &064 &007 %61",  1},
	{ "%55: &007 &072",  1},
	{ "%55: &064 &007 &072",  1},
	{ "%56: %32 %35 &080 %16 &081 %61 &111 %16",  1},
	{ "%56: %32 %29 %35 &080 %16 &081 %61 &111 %16",  1},
	{ "%56: %32 %29 &080 %16 &081 %61 &111 %16",  1},
	{ "%56: %32 %35 &080 &073 &081 %61 &111 %16",  1},
	{ "%56: %32 %29 %35 &080 &073 &081 %61 &111 %16",  1},
	{ "%56: %32 %29 &080 &073 &081 %61 &111 %16",  1},
	{ "%57: %32 %35 &080 %16 &081 %61 &111 %16 &109 %16",  1},
	{ "%57: %32 %29 %35 &080 %16 &081 %61 &111 %16 &109 %16",  1},
	{ "%57: %32 %29 &080 %16 &081 %61 &111 %16 &109 %16",  1},
	{ "%57: %32 %35 &080 &073 &081 %61 &111 %16 &109 %16",  1},
	{ "%57: %32 %29 %35 &080 &073 &081 %61 &111 %16 &109 %16",  1},
	{ "%57: %32 %29 &080 &073 &081 %61 &111 %16 &109 %16",  1},
	{ "%58: &082 %43 &083",  3},
	{ "%58: &082 %43 &083 &076",  3},
	{ "%58: &082 &083",  3},
	{ "%58: &082 &083 &076",  3},
	{ "%59: %60",  3},
	{ "%59: %59 &077 %60",  3},
	{ "%60: %27 %37",  3},
	{ "%82: &126",  3},
	{ "%82: &127",  3},
	{ "%82: &128",  3},
	{ "%82: &129",  3},
	{ "%82: &130",  3},
	{ "%82: &132",  3},
	{ "%82: &133",  3},
	{ "%82: &134",  3},
	{ "%82: &131",  3},
	{ "%82: &135",  3},
	{ "%82: &136",  3},
	{ "%82: &137",  3},
	{ "%82: &138",  3},
	{ "%83: &023",  3},
	{ "%83: &023 %84",  3},
	{ "%84: %85",  3},
	{ "%84: %84 &077 %85",  3},
	{ "%85: &024 &111 &067",  3},
	{ "%85: &025",  3},
	{ "%85: &026",  3},
	{ "%85: &027",  3},
	{ "%85: &028",  3},
	{ "%85: &029",  3},
	{ "%85: &030",  3},
	{ "%85: &031",  3},
	{ "%85: &032",  3},
	{ "%85: &033",  3},
	{ "%85: &034",  3},
	{ "%85: &036",  3},
	{ "%85: &037",  3},
	{ "%85: &035",  3},
	{ "%85: &038",  3},
	{ "%85: &039 &111 &070",  3},
	{ "%85: &040 &111 &070",  3},
	{ "%85: &041 &111 &070",  3},
	{ "%85: &042 &111 &070",  3},
	{ "%02: &056 &070",  3},
	{ "%01: &055 &070",  3},
	{ "%64: %65 %66",  3},
	{ "%65: &017 %61 &080 %33 &081",  1},
	{ "%65: &017 %61 &080 %29 &081",  1},
	{ "%65: &017 %61 &080 %29 %35 &081",  1},
	{ "%66: &082 %67 &083",  3},
	{ "%67: %68",  3},
	{ "%67: %67 &077 %68",  3},
	{ "%68: %71 &077 %70",  3},
	{ "%71: &069",  3},
	{ "%69: %16",  3},
	{ "%69: %69 &077 %16",  3},
	{ "%72: %35 &080 %16 &081",  3},
	{ "%72: %29 %35 &080 %16 &081",  3},
	{ "%73: %72",  3},
	{ "%73: %73 &077 %72",  3},
	{ "%70: %16",  3},
	{ "%70: &082 %69 &083",  3},
	{ "%70: %72",  3},
	{ "%70: &082 %73 &083",  3},
	{ "%70: &070",  3},
	{ "%74: %75 %76",  3},
	{ "%75: &022 %61",  1},
	{ "%76: &082 %77 &083",  3},
	{ "%77: %78",  3},
	{ "%77: %77 &077 %78",  3},
	{ "%78: %81 &077 %80",  3},
	{ "%81: &070",  3},
	{ "%80: %16",  3},
	{ "%80: &070",  3},
	{ "%80: &082 %79 &083",  3},
	{ "%79: %16",  3},
	{ "%79: &070",  3},
	{ "%79: %79 &077 %16",  3},
	{ "%79: %79 &077 &070",  3},
	{ "%49: &074 &080 &067 &081 &076",  3},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "CHAR",  257,  1},
	{ "BIT",  258,  1},
	{ "INT",  259,  1},
	{ "FLOAT",  260,  1},
	{ "DOUBLE",  261,  1},
	{ "CLASS",  262,  2},
	{ "IF",  263,  2},
	{ "ELSE",  264,  2},
	{ "DO",  265,  2},
	{ "WHILE",  266,  2},
	{ "FOR",  267,  2},
	{ "GOTO",  268,  2},
	{ "BREAK",  269,  2},
	{ "CONTINUE",  270,  2},
	{ "REPEAT",  271,  2},
	{ "MAP",  272,  2},
	{ "EXTENDS",  273,  2},
	{ "SWITCH",  274,  2},
	{ "CASE",  275,  2},
	{ "DEFAULT",  276,  2},
	{ "BAC",  277,  2},
	{ "PRAGMA",  278,  2},
	{ "PRAGMA_ARRAY",  279,  2},
	{ "PRAGMA_GET",  280,  2},
	{ "PRAGMA_NOGET",  281,  2},
	{ "PRAGMA_PUT",  282,  2},
	{ "PRAGMA_NOPUT",  283,  2},
	{ "PRAGMA_PUTXML",  284,  2},
	{ "PRAGMA_NOPUTXML",  285,  2},
	{ "PRAGMA_TRACE",  286,  2},
	{ "PRAGMA_NOTRACE",  287,  2},
	{ "PRAGMA_LINE",  288,  2},
	{ "PRAGMA_NOLINE",  289,  2},
	{ "PRAGMA_INCLUDES",  290,  2},
	{ "PRAGMA_NULLSTRINGS",  291,  2},
	{ "PRAGMA_NONULLSTRINGS",  292,  2},
	{ "PRAGMA_NOINCLUDES",  293,  2},
	{ "PRAGMA_BITSTREAM",  294,  2},
	{ "PRAGMA_PREFIX",  295,  2},
	{ "PRAGMA_ERROR_FUNC",  296,  2},
	{ "PRAGMA_TRACE_FUNC",  297,  2},
	{ "BAC_PREC",  298,  2},
	{ "BAC_OOC",  299,  2},
	{ "BAC_SOC",  300,  2},
	{ "BAC_TE",  301,  2},
	{ "BAC_RENORM",  302,  2},
	{ "BAC_BS",  303,  2},
	{ "BAC_INIT",  304,  2},
	{ "BAC_END",  305,  2},
	{ "BAC_RTABLE",  306,  2},
	{ "BAC_NEXTI",  307,  2},
	{ "BAC_TRANS",  308,  2},
	{ "BAC_EXCH",  309,  2},
	{ "INCLUDE",  310,  2},
	{ "IMPORT",  311,  2},
	{ "UNSIGNED",  312,  2},
	{ "SIGNED",  313,  2},
	{ "SHORT",  314,  2},
	{ "LONG",  315,  2},
	{ "CONST",  316,  2},
	{ "ALIGNED",  317,  2},
	{ "STATIC",  318,  2},
	{ "ABSTRACT",  319,  2},
	{ "LITTLE",  320,  2},
	{ "BIG",  321,  2},
	{ "INT_LITERAL",  322,  2},
	{ "DOUBLE_LITERAL",  323,  4},
	{ "BIT_LITERAL",  324,  5},
	{ "STRING_LITERAL",  325,  6},
	{ "VARIABLE",  326,  1},
	{ "CLASS_TYPE",  327,  1},
	{ "MAP_TYPE",  328,  1},
	{ "BAC_TYPE",  329,  1},
	{ "LABEL",  330,  1},
	{ "';'",  59,  2},
	{ "','",  44,  2},
	{ "'?'",  63,  2},
	{ "':'",  58,  2},
	{ "'('",  40,  2},
	{ "')'",  41,  2},
	{ "'{'",  123,  2},
	{ "'}'",  125,  2},
	{ "'+'",  43,  2},
	{ "'-'",  45,  2},
	{ "'*'",  42,  2},
	{ "'/'",  47,  2},
	{ "'<'",  60,  2},
	{ "'>'",  62,  2},
	{ "'|'",  124,  2},
	{ "'&'",  38,  2},
	{ "'^'",  94,  2},
	{ "'%'",  37,  2},
	{ "'['",  91,  2},
	{ "']'",  93,  2},
	{ "'.'",  46,  2},
	{ "'~'",  126,  2},
	{ "'!'",  33,  2},
	{ "LS",  331,  2},
	{ "RS",  332,  2},
	{ "GE",  333,  2},
	{ "LE",  334,  2},
	{ "NE",  335,  2},
	{ "EQ",  336,  2},
	{ "OR",  337,  2},
	{ "AND",  338,  2},
	{ "INC",  339,  2},
	{ "DEC",  340,  2},
	{ "RANGE",  341,  2},
	{ "CLCL",  342,  2},
	{ "'='",  61,  2},
	{ "MUL_ASSIGN",  343,  2},
	{ "DIV_ASSIGN",  344,  2},
	{ "MOD_ASSIGN",  345,  2},
	{ "ADD_ASSIGN",  346,  2},
	{ "SUB_ASSIGN",  347,  2},
	{ "LS_ASSIGN",  348,  2},
	{ "RS_ASSIGN",  349,  2},
	{ "AND_ASSIGN",  350,  2},
	{ "XOR_ASSIGN",  351,  2},
	{ "OR_ASSIGN",  352,  2},
	{ "DBL_BRACE_L",  353,  2},
	{ "DBL_BRACE_R",  354,  2},
	{ "DECL",  355,  0},
	{ "EXPR",  356,  0},
	{ "VERBATIM",  357,  7},
	{ "VERBATIM_GET",  358,  7},
	{ "VERBATIM_PUT",  359,  7},
	{ "VERBATIM_BOTH",  360,  7},
	{ "VERBATIM_C",  361,  7},
	{ "VERBATIM_C_CPP",  362,  7},
	{ "VERBATIM_GET_C",  363,  7},
	{ "VERBATIM_PUT_C",  364,  7},
	{ "VERBATIM_BOTH_C",  365,  7},
	{ "VERBATIM_J",  366,  7},
	{ "VERBATIM_GET_J",  367,  7},
	{ "VERBATIM_PUT_J",  368,  7},
	{ "VERBATIM_BOTH_J",  369,  7},
	{ "LENGTHOF",  370,  2},
	{ "ISIDOF",  371,  2},
	{ "SKIPBITS",  372,  2},
	{ "NEXTBITS",  373,  2},
	{ "SNEXTBITS",  374,  2},
	{ "LITTLE_NEXTBITS",  375,  2},
	{ "LITTLE_SNEXTBITS",  376,  2},
	{ "NEXTCODE",  377,  2},
	{ "NUMBITS",  378,  2},
	{ "ESC_FTYPE",  379,  0},
	{ "ESC_MAP",  380,  0},
	{ "ARRAY",  381,  0},
	{ "LOWER_THAN_ELSE",  382,  0}

};
#endif
static short yydef[] = {

	  28,   42,   32,  286,   31,   29,   -1,   43,   28,   28, 
	 249,  248,   20,  287,   20,   40,   28,   28,   28,  289, 
	  18,  290,  291,  292,  293,  226,    3,  215,  248,   41, 
	  39,   28,   28,   -5,   -9,   28,  288,  227,   28,   19, 
	  17,   16,   15,   14,   13,   12,   11,   10,    9,    8, 
	   7,    6,    5,    4,   23,   22,   21,   25,   24,   28, 
	  28,   28,   27,   26,   28,   30,   28,   28,   28,   28, 
	  28,   28,   28,   36,   33,   38,   35,   28,   37,   34
};
static short yyex[] = {

	   0,    0,   -1,   28,   44,   28,   -1,    1,   44,   28, 
	  -1,    1
};
static short yyact[] = {

	-302, -304,   -2, -300, -299,   -6, -372, -371, -370, -369, 
	-368, -364, -367, -366, -365, -363, -362, -361, -360,  369, 
	 368,  367,  366,  365,  364,  363,  362,  361,  360,  359, 
	 358,  357,  317,  311,  310,  278,  277,  272, -477,  326, 
	-294,  123, -292,  123, -338,  325, -339,  325, -287, -357, 
	-356, -355, -354, -353, -352, -351, -350, -349, -348, -345, 
	-347, -346, -344, -288, -289, -290, -291,  297,  296,  295, 
	 294,  293,  292,  291,  290,  289,  288,  287,  286,  285, 
	 284,  283,  282,  281,  280,  279, -286,   40, -285,  273, 
	  -9,   58, -392,  -10,  123,   59, -284,   40, -512, -511, 
	-513, -514, -515, -282, -502, -503, -504, -505, -506, -283, 
	-507, -508, -429,  327,  321,  320,  319,  316,  315,  314, 
	 313,  312,  262,  261,  260,  259,  258,  257, -281, -501, 
	  59,   44, -313,  325, -278,   40, -330,  324, -275,   61, 
	-274,   61, -273,   61, -272,   61, -271,   61, -270,   44, 
	-512, -511, -513, -514, -515, -502, -503, -504, -505, -506, 
	-507, -508, -429,  327,  321,  320,  316,  315,  314,  313, 
	 312,  261,  260,  259,  258,  257, -477, -389,  327,  326, 
	  -6,  317, -486, -246, -483, -484, -412,  -19,  -16, -485, 
	-259,  -17, -261, -262, -263, -265, -264, -260, -256, -257, 
	  -2, -300, -299,   -6, -475, -474, -473, -477, -266, -481, 
	-482, -372, -371, -370, -369, -368, -364, -367, -366, -365, 
	-363, -362, -361, -360, -249, -250, -251, -254, -252, -253, 
	 378,  377,  373,  372,  371,  370,  369,  368,  367,  366, 
	 365,  364,  363,  362,  361,  360,  359,  358,  357,  340, 
	 339,  329,  326,  324,  323,  322,  317,  311,  310,  278, 
	 276,  275,  274,  270,  269,  268,  267,  266,  265,  263, 
	 126,  125,  123,   59,   45,   43,   40,   33, -486, -246, 
	-483, -484, -485, -475, -474, -473, -477, -481, -482, -249, 
	-250, -251, -254, -252, -253,  378,  377,  373,  372,  371, 
	 370,  340,  339,  326,  324,  323,  322,  126,   45,   43, 
	  40,   33, -244,  262, -477, -383,  327,  326, -243,   40, 
	-242,   40, -241, -512, -511, -513, -514, -515, -502, -503, 
	-504, -505, -506, -507, -508, -429,  327,  321,  320,  316, 
	 315,  314,  313,  312,  261,  260,  259,  258,  257,   40, 
	-240, -238, -239,   91,   61,   40, -237,   44, -236, -316, 
	 125,   44, -233,   44, -232, -333,  125,   44, -340,  325, 
	-341,  325, -342,  325, -343,  325, -358,  322, -387, -231, 
	  44,   41, -512, -511, -513, -514, -515, -502, -503, -504, 
	-505, -506, -507, -508,  321,  320,  316,  315,  314,  313, 
	 312,  261,  260,  259,  258,  257, -228,   40, -374,   59, 
	-396,   59, -397,   59, -227,  330, -226,   40, -486, -246, 
	-483, -484, -412,  -19, -485, -259,  -17, -261, -262, -263, 
	-265, -264, -260, -256, -257,   -2, -300, -299,   -6, -475, 
	-474, -473, -477, -266, -481, -482, -372, -371, -370, -369, 
	-368, -364, -367, -366, -365, -363, -362, -361, -360, -249, 
	-250, -251, -254, -252, -253,  378,  377,  373,  372,  371, 
	 370,  369,  368,  367,  366,  365,  364,  363,  362,  361, 
	 360,  359,  358,  357,  340,  339,  329,  326,  324,  323, 
	 322,  317,  311,  310,  278,  276,  275,  274,  270,  269, 
	 268,  267,  266,  265,  263,  126,  123,   59,   45,   43, 
	  40,   33, -224,   40, -223,   40, -222,   40, -411,   59, 
	-486, -246, -483, -484, -412,  -19,  -31, -485, -259,  -17, 
	-261, -262, -263, -265, -264, -260, -256, -257,   -2, -300, 
	-299,   -6, -475, -474, -473, -477, -266, -481, -482, -372, 
	-371, -370, -369, -368, -364, -367, -366, -365, -363, -362, 
	-361, -360, -249, -250, -251, -254, -252, -253,  378,  377, 
	 373,  372,  371,  370,  369,  368,  367,  366,  365,  364, 
	 363,  362,  361,  360,  359,  358,  357,  340,  339,  329, 
	 326,  324,  323,  322,  317,  311,  310,  278,  276,  275, 
	 274,  270,  269,  268,  267,  266,  265,  263,  126,  125, 
	 123,   59,   45,   43,   40,   33, -486, -246, -483, -484, 
	-412,  -19, -415, -485, -259,  -17, -261, -262, -263, -265, 
	-264, -260, -256, -257,   -2, -300, -299,   -6, -475, -474, 
	-473, -477, -266, -481, -482, -372, -371, -370, -369, -368, 
	-364, -367, -366, -365, -363, -362, -361, -360, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 369,  368,  367,  366,  365,  364,  363,  362,  361,  360, 
	 359,  358,  357,  340,  339,  329,  326,  324,  323,  322, 
	 317,  311,  310,  278,  276,  275,  274,  270,  269,  268, 
	 267,  266,  265,  263,  126,  125,  123,   59,   45,   43, 
	  40,   33,  -33,   58, -220, -219,  337,   63, -218,  338, 
	-212, -213, -215, -214, -217, -216,  336,  335,  334,  333, 
	  62,   60, -209, -210, -211, -207, -208,  332,  331,  124, 
	  94,   38, -205, -206,   45,   43, -204, -202, -203,   47, 
	  42,   37, -489, -490, -491, -492, -493, -494, -495, -496, 
	-497, -498, -499,  352,  351,  350,  349,  348,  347,  346, 
	 345,  344,  343,   61,  -34,   40, -200,   40,  -35,   40, 
	-199,   40, -198,   40, -197,   40, -467, -196, -469, -468, 
	 340,  339,   91,   46,  -36,   58, -430,   41, -477, -382, 
	 327,  326, -194,  328, -486, -246, -483, -484, -485, -475, 
	-474, -473, -477, -192, -193, -481, -482, -249, -250, -251, 
	-254, -252, -253,  378,  377,  373,  372,  371,  370,  340, 
	 339,  329,  328,  326,  324,  323,  322,  126,   45,   43, 
	  40,   33, -190,   40, -486, -246, -483, -484, -485, -475, 
	-474, -473, -477, -189, -481, -482, -249, -250, -251, -254, 
	-252, -253,  378,  377,  373,  372,  371,  370,  340,  339, 
	 328,  326,  324,  323,  322,  126,   45,   43,   40,   33, 
	-486, -246, -483, -484, -186, -485, -475, -474, -473, -477, 
	-481, -482, -249, -250, -251, -254, -252, -253,  378,  377, 
	 373,  372,  371,  370,  340,  339,  326,  324,  323,  322, 
	 126,   91,   45,   43,   40,   33, -486, -246, -483, -484, 
	-184, -485, -475, -474, -473, -425, -477, -481, -482, -249, 
	-250, -251, -254, -252, -253,  378,  377,  373,  372,  371, 
	 370,  340,  339,  326,  325,  324,  323,  322,  126,  123, 
	  45,   43,   40,   33, -486, -246, -483, -484, -183, -485, 
	-475, -474, -473, -311, -477, -481, -482, -249, -250, -251, 
	-254, -252, -253,  378,  377,  373,  372,  371,  370,  340, 
	 339,  326,  325,  324,  323,  322,  126,  123,   45,   43, 
	  40,   33, -336,   41, -335, -512, -511, -513, -514, -515, 
	-502, -503, -504, -505, -506, -507, -508,  321,  320,  316, 
	 315,  314,  313,  312,  261,  260,  259,  258,  257,   41, 
	-486, -246, -483, -484, -181, -485, -512, -511, -513, -514, 
	-515, -502, -503, -504, -505, -506, -507, -508, -475, -474, 
	-473, -319, -477, -481, -482, -249, -250, -251, -254, -252, 
	-253,  378,  377,  373,  372,  371,  370,  340,  339,  326, 
	 325,  324,  323,  322,  321,  320,  316,  315,  314,  313, 
	 312,  261,  260,  259,  258,  257,  126,  123,   45,   43, 
	  40,   33, -239,   91, -178,   40, -177, -512, -511, -513, 
	-514, -515, -502, -503, -504, -505, -506, -507, -508,  321, 
	 320,  316,  315,  314,  313,  312,  261,  260,  259,  258, 
	 257,   40, -175,  322, -398,   59, -486, -246, -483, -484, 
	-174, -485, -475, -474, -473, -477, -481, -482, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 340,  339,  326,  324,  323,  322,  126,   59,   45,   43, 
	  40,   33, -172,  266, -375,   59, -486, -246, -483, -484, 
	-412,  -19, -414, -485, -259,  -17, -261, -262, -263, -265, 
	-264, -260, -256, -257,   -2, -300, -299,   -6, -475, -474, 
	-473, -477, -266, -481, -482, -372, -371, -370, -369, -368, 
	-364, -367, -366, -365, -363, -362, -361, -360, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 369,  368,  367,  366,  365,  364,  363,  362,  361,  360, 
	 359,  358,  357,  340,  339,  329,  326,  324,  323,  322, 
	 317,  311,  310,  278,  276,  275,  274,  270,  269,  268, 
	 267,  266,  265,  263,  126,  125,  123,   59,   45,   43, 
	  40,   33,  -39,   58, -486, -246, -483, -484, -485, -502, 
	-503, -504, -505, -506,   -6, -507, -508, -475, -474, -473, 
	-477, -481, -482, -249, -250, -251, -254, -252, -253,  378, 
	 377,  373,  372,  371,  370,  340,  339,  326,  324,  323, 
	 322,  321,  320,  317,  316,  315,  314,  313,  312,  126, 
	  45,   43,   40,   33, -460,   41,   -6, -163,  324,  317, 
	-161,  327, -246, -475, -474, -473, -477,  326,  324,  323, 
	 322,   40, -472,   41,  -55,   41, -433,   41,  -56,   41, 
	 -57,   41, -486, -246, -483, -484, -485, -475, -474, -473, 
	-477, -158, -481, -482, -249, -250, -251, -254, -252, -253, 
	 378,  377,  373,  372,  371,  370,  340,  339,  328,  326, 
	 324,  323,  322,  126,   45,   43,   40,   33,  -58,   41, 
	 -59,   41, -420,   41, -156,   44, -422,   93, -153,  341, 
	-486, -246, -483, -484, -485, -475, -474, -473, -308, -477, 
	-481, -482, -249, -250, -251, -254, -252, -253,  378,  377, 
	 373,  372,  371,  370,  340,  339,  326,  325,  324,  323, 
	 322,  126,   45,   43,   40,   33, -334,   41, -486, -246, 
	-483, -484, -485, -512, -511, -513, -514, -515, -502, -503, 
	-504, -505, -506, -507, -508, -475, -474, -473, -477, -481, 
	-482, -249, -250, -251, -254, -252, -253,  378,  377,  373, 
	 372,  371,  370,  340,  339,  326,  324,  323,  322,  321, 
	 320,  316,  315,  314,  313,  312,  261,  260,  259,  258, 
	 257,  126,   45,   43,   40,   33, -149,   40, -486, -246, 
	-483, -484, -485, -475, -474, -473, -477, -147, -481, -482, 
	-249, -250, -251, -254, -252, -253,  378,  377,  373,  372, 
	 371,  370,  340,  339,  328,  326,  324,  323,  322,  126, 
	  45,   43,   40,   33, -486, -246, -483, -484, -485, -475, 
	-474, -473, -477, -145, -481, -482, -249, -250, -251, -254, 
	-252, -253,  378,  377,  373,  372,  371,  370,  340,  339, 
	 328,  326,  324,  323,  322,  126,   45,   43,   40,   33, 
	-143,   40, -142,   41, -486, -246, -483, -484, -141, -485, 
	-475, -474, -473, -477, -481, -482, -249, -250, -251, -254, 
	-252, -253,  378,  377,  373,  372,  371,  370,  340,  339, 
	 326,  324,  323,  322,  126,   59,   45,   43,   40,   33, 
	-138, -139,   59,   44, -137,   40,  -60, -219,  337,   41, 
	 -61,   41,  -62, -219,  337,   41, -136,   58, -135,   44, 
	-134,   44, -459,   41, -133,   44, -462,   41, -463,   41, 
	-132,   44, -465, -467, -196, -469, -468,  340,  339,   91, 
	  46,   41, -471,   93, -438,   42, -439,   42, -440,   42, 
	 -63,   41,  -64,   41, -436,   42, -437,   42, -131,   93, 
	-130, -426,  125,   44, -129, -310,  125,   44, -128, -320, 
	 125,   44, -127, -322,  125,   44, -125,   40, -124,   41, 
	-123,   41, -122,   41, -121,   41, -486, -246, -483, -484, 
	-485, -475, -474, -473, -477, -120, -481, -482, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 340,  339,  328,  326,  324,  323,  322,  126,   45,   43, 
	  40,   33, -305,   59, -486, -246,  -65, -483, -484, -485, 
	-475, -474, -473, -477, -481, -482, -249, -250, -251, -254, 
	-252, -253,  378,  377,  373,  372,  371,  370,  340,  339, 
	 326,  324,  323,  322,  126,   45,   43,   41,   40,   33, 
	-117, -219,  337,   59, -486, -246, -483, -484, -116, -485, 
	-475, -474, -473, -477, -481, -482, -249, -250, -251, -254, 
	-252, -253,  378,  377,  373,  372,  371,  370,  340,  339, 
	 326,  324,  323,  322,  126,   59,   45,   43,   40,   33, 
	-486, -246, -483, -484, -485, -502, -503, -504, -505, -506, 
	-507, -508, -475, -474, -473, -477, -481, -482, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 340,  339,  326,  324,  323,  322,  321,  320,  316,  315, 
	 314,  313,  312,  126,   45,   43,   40,   33, -110,  324, 
	-434,   42, -435,   42, -421,   93, -486, -246, -483, -484, 
	-485, -475, -474, -473, -306, -477, -481, -482, -249, -250, 
	-251, -254, -252, -253,  378,  377,  373,  372,  371,  370, 
	 340,  339,  326,  325,  324,  323,  322,  126,   45,   43, 
	  40,   33, -327,   41, -103,   41, -102,   41,  -67, -138, 
	  44,   41, -486, -246,  -68, -483, -484, -485, -475, -474, 
	-473, -477, -481, -482, -249, -250, -251, -254, -252, -253, 
	 378,  377,  373,  372,  371,  370,  340,  339,  326,  324, 
	 323,  322,  126,   45,   43,   41,   40,   33, -486, -246, 
	 -69, -483, -484, -485, -475, -474, -473, -477, -481, -482, 
	-249, -250, -251, -254, -252, -253,  378,  377,  373,  372, 
	 371,  370,  340,  339,  326,  324,  323,  322,  126,   45, 
	  43,   41,   40,   33,  -99, -219,  337,   59,  -98, -219, 
	 337,   41,  -70,  264,  -97,   44, -457,   41, -458,   41, 
	-461,   41, -464,   41, -326,   41,  -96,   61,  -95,   61, 
	 -94,   61,  -93,   61,  -71, -138,   44,   41,  -72, -138, 
	  44,   41, -486, -246,  -73, -483, -484, -485, -475, -474, 
	-473, -477, -481, -482, -249, -250, -251, -254, -252, -253, 
	 378,  377,  373,  372,  371,  370,  340,  339,  326,  324, 
	 323,  322,  126,   45,   43,   41,   40,   33, -407,   59, 
	 -88,   61,  -87,   61,  -78, -138,   44,   41, -456,   41, 
	 -86,  341,  -85,  341,  -84,  341,  -83,  341,  -82,  341, 
	 -81,  341,   -1
};
static short yypact[] = {

	  19,   67,   87,   89,   91,   97,   19,  149,  181,  230, 
	 319,  321,  336,  353,  163,  409,  465,  568,  664,  716, 
	 719,  726,  737,  744,  749,  763,  790,  795,  843, 1083, 
	1155, 1204,  465, 1279, 1308,  465, 1375, 1379,  465,  719, 
	 726,  737,  737,  737,  737,  737,  737,  744,  744,  744, 
	 744,  744,  749,  749, 1635, 1637, 1639, 1645, 1647,  465, 
	 465,  465, 1841, 1843,  465, 1973,  465,  465,  465,  465, 
	 465,  465,  465, 2051, 2053, 2055, 2057,  465, 2059, 2061, 
	 295,  295,  295,  295,  295,  295,  295,  295, 2049, 2046, 
	2043, 2041,  295,  295,  295,  295, 1814, 2039, 2020, 2000, 
	1996,   39,   39, 1993, 1991, 1989, 1987, 1985, 1983, 1981, 
	1979, 1977, 1975, 1970, 1966, 1946, 1910, 1890, 1887, 1885, 
	  39,   39,   39,   39,  295, 1883,  295,  394, 1864,  935, 
	1845,  295, 1839, 1814, 1814,  295,  295,  295, 1772, 1752, 
	1732, 1713, 1694, 1675, 1673, 1671, 1669, 1667,  295, 1664, 
	1660, 1656,  295, 1652, 1649,  295, 1643, 1641, 1633, 1627, 
	1621, 1619, 1617, 1615, 1613, 1611, 1609, 1607, 1604, 1601, 
	1598, 1595, 1592, 1572, 1553, 1551, 1532, 1496,  394, 1477, 
	1447, 1417, 1398,  935, 1377,  295, 1373, 1371, 1369, 1350, 
	1331, 1329, 1327, 1325, 1323,  295, 1317, 1311,  295, 1305, 
	 295,  295,  295,  295,  295,  295,  295,  295,  295,  295, 
	 295,  295,  295,  295,  295,  295,  295,  295,  295,  295, 
	1253,  295,  295,  295, 1153, 1134, 1115, 1113, 1099, 1085, 
	 163,  137, 1051, 1007,  993,  133,  973,  935,  898,  295, 
	 862,  823,  803,  800,  797,  295,   39,  295,  785,  783, 
	 781,  779,  777,  775,  163,  295,  713,  519,  517,  515, 
	 513,  417,  415,  413,  411,  407,  394,  380,   39,   67, 
	 377,  375,  373,  371,  369,  366,  363,  163,  360,  357, 
	  39,  316,  313,  295,  178,  163,  147,  145,  143,  141, 
	 139,  137,  135,  133,  130,   39,  113,   94,   47,   45, 
	  43,   39,   41,   39
};
static short yygo[] = {

	-540, -540, -533,    6,    0, -541, -541, -534,    6,    0, 
	-478, -160,  -27,  196, -247,  -26,  -26,  -26,  -26,  -26, 
	 -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26, 
	 -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26, 
	 -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26,  -26, 
	 -26,  -26, -453, -452, -451,  -26,  -26,  -26,  -26,  -26, 
	 -26, -466, -487,  247,  245,  239,  238,  237,  225,  222, 
	 203,  202,  201,  200,  198,  195,  185,  183,  155,  140, 
	 137,  134,  133,  131,  129,  116,  115,   98,   96,   77, 
	  72,   71,   70,   69,   68,   67,   66,   64,   61,   60, 
	  59,   38,   35,   33,   32,   31,   18,   17,   16,    9, 
	-479, -480, -248,  -54,  -53,  -25,  205,  204,  -52,  -51, 
	 -50,  -49,  -48,  -24,  210,  209,  208,  207,  206,  -47, 
	 -46,  -45,  -44,  -43,  -42,  -23,  216,  215,  214,  213, 
	 212,  211,  -41,  -22,  217,  -40,  -21,  218, -114, -115, 
	-140, -169, -171,  -20,  223,  221,  173,  138,  136, -380, 
	-377, -379, -376, -381, -378,  -80,  -79,  -77,  -76,  -75, 
	 -74, -108, -328, -307, -450, -119, -126, -419, -144, -146, 
	-329, -309, -157, -168, -323, -312,  -38, -188, -191, -221, 
	-245, -488,  283,  255,  241,  240,  237,  236,  232,  219, 
	 189,  182,  180,  177,  176,  152,  148,  142,  135,  128, 
	 126,  124,   95,   94,   93,   92,   87,   86,   85,   84, 
	  83,   82,   81,   80, -165,  -89, -500, -500, -500, -519, 
	-109, -111, -112, -448, -500,  -37, -519, -155, -159, -162, 
	-449, -170, -500, -428, -185,  -37, -195, -258,  245,  239, 
	 238,  237,  225,  222,  200,  198,  195,  185,  183,  155, 
	 140,  137,  134,  133,  131,  129,  116,  115,   98,   96, 
	  33,  -90, -100, -101, -118, -173,  140,  116,  115,   98, 
	-447, -187,  155, -201, -427, -520,  237, -424, -518,  129, 
	-154, -535, -535, -530,    6,    0, -295, -296, -269, -269, 
	-444,  285,  230, -443,  -15,  -13, -229, -234,  -15,  -13, 
	-179,  296,  285,  277,  266,  254,  230, -431, -431, -455, 
	-454, -454, -455, -431, -431, -431, -432,  233,  228,  178, 
	 134,  133,   96,   33,   14,   12, -113, -166,  134, -297, 
	-297, -267, -167, -164, -255,   34,   33,    8,    6,    0, 
	-441, -441, -235, -442,  277,   14,   12,  -11,  -11, -510, 
	 296,  254,  -29, -180, -148, -180, -176, -180, -182,  -12, 
	-230,  -12, -509,  296,  266,  254,  233,  232,  228,  180, 
	 178,  127,   12, -445, -446,  280,  -30,  -14,  268, -516, 
	-517, -529, -521, -522,  -32,  -18,   18, -225, -413, -413, 
	-416, -418, -417, -408, -409,  -66, -406, -405, -404, -402, 
	-410, -403, -401, -400, -399, -528,   77,   72,   71,   70, 
	  69,   68,   67,   66,   64,   61,   60,   59,   38,   35, 
	  32,   31,   17,   16, -523, -524, -525, -526, -527, -536, 
	-298,   -5,   -4,   -3, -386, -391, -390, -393, -268, -373, 
	-543,  230,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28, 
	 -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28,  -28, 
	 -28,  -28,  -91,  -92, -104, -105, -106, -107, -384, -470, 
	-423, -423, -385, -388, -423, -293, -317, -476,  303,  301, 
	 295,  284,  281,  280,  268,  246,  243,  123,  122,  121, 
	 120,  102,  101,   77,   72,   71,   70,   69,   68,   67, 
	  66,   64,   61,   60,   59,   38,   35,   32,   31,   18, 
	  17,   16,    9,   -7, -394, -395,    6, -537, -301, -337, 
	-276, -332, -545,  231, -150, -331, -277, -324, -325, -321, 
	 180,  127, -151, -542, -303, -318, -279, -315, -546,  235, 
	-152, -314, -280, -538, -538, -531,    6,    0, -539, -539, 
	-532,    6,    0,   -8, -359, -544,  269,   -1
};
static short yypgo[] = {

	   0,    0,    0,   62,  123,  123,  135,  135,  135,  135, 
	 135,  143,  143,  143,  143,  143,  143,  146,  153,  153, 
	 300,  303,  303,  303,  303,  303,  303,  303,  344,  344, 
	 435,  440,  442,  445,  445,  445,  445,  445,  445,  447, 
	 447,  450,  560,  560,  438,  550,  550,  550,  550,  551, 
	 551,  551,  552,  548,  546,  545,  544,  543,  535,  535, 
	 535,  535,  535,  542,  542,  539,  539,  534,  534,  536, 
	 532,  530,  529,  528,  528,  528,  527,    2,    7,  565, 
	 565,  565,  565,  565,  565,  565,  565,  565,  565,  565, 
	 565,  565,  565,  565,  565,  565,  565,  565,  563,  555, 
	 555,  555,  555,  555,  555,  555,  555,  555,  555,  555, 
	 555,  555,  448,  447,  447,  446,  446,  446,  446,  446, 
	 446,  444,  444,  444,  444,  443,  442,  441,  441,  440, 
	 440,  439,  439,  523,  523,  437,  437,  437,  436,  436, 
	 436,  436,  436,  436,  436,  436,  436,  436,  435,  435, 
	 434,  434,  395,  393,  393,  392,  392,  392,  390,  389, 
	 387,  387,  387,  290,  285,  285,  384,  384,  359,  344, 
	 310,  310,  303,  303,  303,  303,  303,  303,  303,  303, 
	 300,  300,  297,  297,  296,  296,  281,  275,  247,  191, 
	 115,  115,  115,  337,  337,  111,  111,  111,  111,  110, 
	 110,  110,  110,  110,  110,   62,   14,   12,   12,   12, 
	  12,   10,   10,   10,   10,   10,  487,   12,   62,  110, 
	 112,  112,  112,  112,  112,  112,  115,  247,  283,  283, 
	 283,  283,  283,  283,  283,  283,  283,  283,  283,  275, 
	 293,  326,  326,  326,  326,  326,  326,  326,  353,  353, 
	 372,  372,  372,  372,  372,  384,  384,  290,  288,  288, 
	 391,  391,  391,  391,  391,  391,  391,  395,  415,  415, 
	 415,  415,  415,  415,  525,  525,  525,  525,  525,  525, 
	 525,  525,  448,  563,  530,  546,  441,  384,  281,  191, 
	 146,  143,  135,  123,    0
};
static short yyrlen[] = {

	   0,    0,    0,    1,    3,    3,    3,    3,    3,    3, 
	   3,    3,    3,    3,    3,    3,    3,    3,    1,    3, 
	   1,    4,    4,    4,    4,    4,    5,    5,    0,    1, 
	   5,    1,    1,    8,    9,    8,    8,    9,    8,    3, 
	   2,    2,    1,    2,    5,    3,    3,    1,    1,    3, 
	   1,    1,    1,    3,    3,    3,    2,    2,    1,    3, 
	   1,    3,    1,    3,    1,    5,    4,    3,    1,    1, 
	   3,    3,    3,    6,    5,    5,    2,    2,    2,    3, 
	   3,    3,    3,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    3,    3,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    3,    3,    4,   10,   11,   10,   10,   11, 
	  10,    3,    2,    3,    2,    2,    4,    3,    3,    3, 
	   3,    2,    2,    2,    1,    2,    2,    3,    9,    8, 
	   8,    7,    8,    7,    7,    6,    7,    5,    5,    7, 
	   2,    1,    2,    3,    2,    3,    4,    3,    5,    4, 
	   6,    4,    1,    3,    1,    3,    3,    3,    1,    4, 
	   2,    1,    4,    6,    6,    5,    5,    5,    5,    5, 
	   2,    1,    2,    2,    3,    2,    3,    3,    3,    5, 
	   3,    3,    3,    3,    1,    8,    6,    6,    4,    3, 
	   6,    4,    4,    6,    4,    2,    2,    2,    2,    2, 
	   4,    3,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   2,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    2
};
#define YYS0	0
#define YYDELTA	260
#define YYNPACT	304
#define YYNDEF	80

#define YYr292	0
#define YYr293	1
#define YYr294	2
#define YYr14	3
#define YYr40	4
#define YYr41	5
#define YYr43	6
#define YYr44	7
#define YYr45	8
#define YYr46	9
#define YYr47	10
#define YYr49	11
#define YYr50	12
#define YYr51	13
#define YYr52	14
#define YYr53	15
#define YYr54	16
#define YYr56	17
#define YYr57	18
#define YYr58	19
#define YYr84	20
#define YYr86	21
#define YYr87	22
#define YYr88	23
#define YYr92	24
#define YYr93	25
#define YYr96	26
#define YYr97	27
#define YYr110	28
#define YYr111	29
#define YYr159	30
#define YYr187	31
#define YYr193	32
#define YYr200	33
#define YYr201	34
#define YYr202	35
#define YYr203	36
#define YYr204	37
#define YYr205	38
#define YYr212	39
#define YYr214	40
#define YYr218	41
#define YYr232	42
#define YYr233	43
#define YYr291	44
#define YYr290	45
#define YYr289	46
#define YYr288	47
#define YYr287	48
#define YYr286	49
#define YYr285	50
#define YYr284	51
#define YYr283	52
#define YYr282	53
#define YYr281	54
#define YYr279	55
#define YYr278	56
#define YYr277	57
#define YYr276	58
#define YYr275	59
#define YYr274	60
#define YYr273	61
#define YYr272	62
#define YYr271	63
#define YYr270	64
#define YYr269	65
#define YYr268	66
#define YYr267	67
#define YYr266	68
#define YYr265	69
#define YYr264	70
#define YYr263	71
#define YYr261	72
#define YYr260	73
#define YYr259	74
#define YYr258	75
#define YYr257	76
#define YYr256	77
#define YYr255	78
#define YYr254	79
#define YYr253	80
#define YYr252	81
#define YYr251	82
#define YYr250	83
#define YYr249	84
#define YYr248	85
#define YYr247	86
#define YYr246	87
#define YYr245	88
#define YYr244	89
#define YYr243	90
#define YYr242	91
#define YYr241	92
#define YYr240	93
#define YYr239	94
#define YYr238	95
#define YYr237	96
#define YYr236	97
#define YYr235	98
#define YYr231	99
#define YYr230	100
#define YYr229	101
#define YYr228	102
#define YYr227	103
#define YYr226	104
#define YYr225	105
#define YYr224	106
#define YYr223	107
#define YYr222	108
#define YYr221	109
#define YYr220	110
#define YYr219	111
#define YYr217	112
#define YYr215	113
#define YYr213	114
#define YYr211	115
#define YYr210	116
#define YYr209	117
#define YYr208	118
#define YYr207	119
#define YYr206	120
#define YYr199	121
#define YYr198	122
#define YYr197	123
#define YYr196	124
#define YYr195	125
#define YYr194	126
#define YYr192	127
#define YYr191	128
#define YYr189	129
#define YYr188	130
#define YYr186	131
#define YYr185	132
#define YYr176	133
#define YYr175	134
#define YYr174	135
#define YYr173	136
#define YYr172	137
#define YYr171	138
#define YYr170	139
#define YYr169	140
#define YYr168	141
#define YYr167	142
#define YYr166	143
#define YYr165	144
#define YYr164	145
#define YYr163	146
#define YYr162	147
#define YYr161	148
#define YYr160	149
#define YYr158	150
#define YYr157	151
#define YYr150	152
#define YYr148	153
#define YYr147	154
#define YYr146	155
#define YYr145	156
#define YYr144	157
#define YYr136	158
#define YYr135	159
#define YYr134	160
#define YYr133	161
#define YYr132	162
#define YYr129	163
#define YYr127	164
#define YYr126	165
#define YYr123	166
#define YYr122	167
#define YYr120	168
#define YYr112	169
#define YYr102	170
#define YYr101	171
#define YYr100	172
#define YYr99	173
#define YYr98	174
#define YYr95	175
#define YYr94	176
#define YYr91	177
#define YYr90	178
#define YYr89	179
#define YYr85	180
#define YYr83	181
#define YYr82	182
#define YYr81	183
#define YYr80	184
#define YYr79	185
#define YYr77	186
#define YYr75	187
#define YYr62	188
#define YYr60	189
#define YYr38	190
#define YYr37	191
#define YYr36	192
#define YYr28	193
#define YYr27	194
#define YYr26	195
#define YYr25	196
#define YYr24	197
#define YYr23	198
#define YYr22	199
#define YYr21	200
#define YYr20	201
#define YYr18	202
#define YYr17	203
#define YYr16	204
#define YYr15	205
#define YYr12	206
#define YYr11	207
#define YYr10	208
#define YYr9	209
#define YYr8	210
#define YYr5	211
#define YYr4	212
#define YYr3	213
#define YYr2	214
#define YYr1	215
#define YYrACCEPT	YYr292
#define YYrERROR	YYr293
#define YYrLR2	YYr294
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"include_file",
	"import_file",
	"primary_expr",
	"postfix_expr",
	"rescoped_expr",
	"unary_expr",
	"builtin_function",
	"nextbits_function",
	"unary_operator",
	"multiplicative_expr",
	"additive_expr",
	"shift_expr",
	"relational_expr",
	"logical_and_expr",
	"logical_or_expr",
	"conditional_expr",
	"assignment_expr",
	"assignment_expr_list",
	"argument_expr_list",
	"assignment_operator",
	"array",
	"array_expr",
	"array_expr_list",
	"declaration",
	"declaration_list",
	"type_info",
	"plain_type_info",
	"parsable_type_info",
	"declaration_modifiers",
	"modifier",
	"modifier_list",
	"alignment_modifier",
	"type_specifier",
	"user_type_specifier",
	"builtin_type_specifier",
	"init_declarator",
	"declarator",
	"declarator_with_params",
	"declarator_with_range",
	"statement",
	"labeled_statement",
	"compound_statement",
	"statement_or_declaration_list",
	"statement_or_declaration",
	"expression_statement",
	"selection_statement",
	"iteration_statement",
	"jump_statement",
	"bac_statement",
	"class_definition",
	"complex_class_declarator",
	"derived_class_declarator",
	"param_class_declarator",
	"aligned_class_declarator",
	"class_declarator",
	"id_declarator",
	"id_range_declarator",
	"class_body",
	"parameter_list",
	"parameter_declaration",
	"identifier",
	"program",
	"external_definition",
	"map_definition",
	"map_declarator",
	"map_body",
	"map_entry_list",
	"map_entry",
	"map_entry_item_list",
	"map_entry_item",
	"map_code",
	"map_entry_item_escape",
	"map_entry_item_escape_list",
	"bac_definition",
	"bac_declarator",
	"bac_body",
	"bac_entry_list",
	"bac_entry",
	"bac_entry_item_list",
	"bac_entry_item",
	"bac_keyword",
	"verbatim",
	"pragma",
	"pragma_list",
	"pragma_item",
	0
};
short yyrmap[] = {

	 292,  293,  294,   14,   40,   41,   43,   44,   45,   46, 
	  47,   49,   50,   51,   52,   53,   54,   56,   57,   58, 
	  84,   86,   87,   88,   92,   93,   96,   97,  110,  111, 
	 159,  187,  193,  200,  201,  202,  203,  204,  205,  212, 
	 214,  218,  232,  233,  291,  290,  289,  288,  287,  286, 
	 285,  284,  283,  282,  281,  279,  278,  277,  276,  275, 
	 274,  273,  272,  271,  270,  269,  268,  267,  266,  265, 
	 264,  263,  261,  260,  259,  258,  257,  256,  255,  254, 
	 253,  252,  251,  250,  249,  248,  247,  246,  245,  244, 
	 243,  242,  241,  240,  239,  238,  237,  236,  235,  231, 
	 230,  229,  228,  227,  226,  225,  224,  223,  222,  221, 
	 220,  219,  217,  215,  213,  211,  210,  209,  208,  207, 
	 206,  199,  198,  197,  196,  195,  194,  192,  191,  189, 
	 188,  186,  185,  176,  175,  174,  173,  172,  171,  170, 
	 169,  168,  167,  166,  165,  164,  163,  162,  161,  160, 
	 158,  157,  150,  148,  147,  146,  145,  144,  136,  135, 
	 134,  133,  132,  129,  127,  126,  123,  122,  120,  112, 
	 102,  101,  100,   99,   98,   95,   94,   91,   90,   89, 
	  85,   83,   82,   81,   80,   79,   77,   75,   62,   60, 
	  38,   37,   36,   28,   27,   26,   25,   24,   23,   22, 
	  21,   20,   18,   17,   16,   15,   12,   11,   10,    9, 
	   8,    5,    4,    3,    2,    1,    6,    7,   13,   19, 
	  29,   30,   31,   32,   33,   34,   35,   61,   63,   64, 
	  65,   66,   67,   68,   69,   70,   71,   72,   73,   74, 
	  78,  103,  104,  105,  106,  107,  108,  109,  113,  114, 
	 115,  116,  117,  118,  119,  124,  125,  128,  130,  131, 
	 137,  138,  139,  140,  141,  142,  143,  149,  151,  152, 
	 153,  154,  155,  156,  177,  178,  179,  180,  181,  182, 
	 183,  184,  216,  234,  262,  280,  190,  121,   76,   59, 
	  55,   48,   42,   39,    0
};
short yysmap[] = {

	   0,    7,   21,   22,   23,   34,   38,   68,   71,   72, 
	  93,   94,   95,  102,  127,  134,  139,  151,  153,  165, 
	 166,  167,  168,  169,  170,  171,  188,  194,  204,  225, 
	 241,  243,  245,  278,  280,  291,  303,  310,  343,  345, 
	 346,  347,  348,  349,  350,  351,  352,  353,  354,  355, 
	 356,  357,  358,  359,  377,  379,  380,  383,  384,  415, 
	 416,  417,  432,  433,  456,  465,  490,  491,  493,  497, 
	 512,  514,  515,  520,  521,  522,  523,  529,  535,  536, 
	 543,  542,  534,  533,  532,  531,  525,  524,  519,  516, 
	 509,  508,  507,  506,  505,  504,  498,  496,  495,  494, 
	 492,  488,  487,  486,  485,  484,  483,  482,  472,  471, 
	 470,  468,  467,  462,  460,  459,  458,  457,  454,  453, 
	 452,  451,  450,  449,  448,  447,  446,  444,  441,  438, 
	 437,  426,  423,  421,  420,  419,  414,  413,  412,  411, 
	 410,  409,  408,  407,  406,  405,  404,  403,  402,  400, 
	 398,  396,  393,  392,  387,  386,  382,  381,  374,  373, 
	 372,  371,  370,  369,  367,  366,  365,  344,  339,  338, 
	 337,  336,  334,  333,  331,  330,  329,  328,  325,  323, 
	 321,  317,  311,  307,  305,  304,  302,  301,  300,  299, 
	 298,  297,  296,  295,  290,  289,  283,  282,  281,  279, 
	 277,  265,  264,  263,  262,  261,  260,  259,  258,  257, 
	 256,  255,  254,  253,  252,  251,  250,  249,  248,  247, 
	 246,  239,  238,  237,  236,  235,  234,  230,  229,  228, 
	 226,  217,  216,  215,  214,  212,  211,  209,  208,  207, 
	 205,  202,  201,  198,  195,  190,  187,  185,  184,  183, 
	 182,  180,  179,  178,  163,  155,  154,  143,  142,  141, 
	 140,  138,  137,  136,  135,  133,  130,  124,  122,  121, 
	 120,  119,  118,  117,  116,  115,  113,  111,  110,  108, 
	 104,   77,   76,   75,   70,   69,   66,   51,   50,   49, 
	  48,   44,   43,   41,   37,   36,   35,   24,    6,    5, 
	   4,    3,    2,    1,  455,  477,  478,  394,  395,  442, 
	 312,  313,  107,  314,  315,  213,   39,   42,  319,  443, 
	 320,  445,  322,  479,  399,  503,  481,  480,  401,  112, 
	 324,  326,  218,  397,  318,  316,   45,   46,   47,  219, 
	 220,  221,  222,   52,   53,   54,   55,   56,   57,   58, 
	  59,   60,   61,   62,   63,   64,   65,  223,  224,    8, 
	   9,   10,   11,   12,   13,   14,   15,   16,   17,   18, 
	  19,   20,  327,  231,  340,  540,  544,  538,  541,  545, 
	 539,  293,  199,  294,  200,   78,  227,  128,  129,  131, 
	 132,   73,   74,  106,   33,  232,  233,  332,  537,  528, 
	 527,  513,  526,  511,  510,  489,  517,  463,  464,  518, 
	 240,  144,  242,  341,  244,  342,  418,  376,  440,  385, 
	 475,  388,   99,  476,  306,  439,  308,  309,   79,  292, 
	 203,   92,  378,  473,  474,  434,  435,  429,  430,  431, 
	 206,   96,   97,   98,  210,  103,  436,  461,  363,  466, 
	 360,  361,  362,  469,  364,  530,  499,  500,  422,  368, 
	 501,  424,  425,  502,  427,  284,  286,  287,  288,  285, 
	 428,  375,  191,  192,  193,  197,   40,  189,  186,  181, 
	 177,  176,  175,  174,  173,  172,  196,  164,  276,  275, 
	 274,  273,  272,  271,  270,  269,  268,  267,  266,  335, 
	 105,   91,   90,   89,   88,   87,   86,   85,  126,  125, 
	  84,   83,   82,   81,   80,  101,  100,  391,  390,  389, 
	 162,  161,  160,  159,  158,  157,  156,  152,  150,  149, 
	 148,  147,  146,  145,   32,   31,   30,   29,   28,   27, 
	  26,   25,  123,   67,  114,  109
};
int yyntoken = 152;
int yynvar = 86;
int yynstate = 546;
int yynrule = 295;
#endif

#if YYDEBUG
/*
 * Package up YACC context for tracing
 */
typedef struct yyTraceItems_tag {
	int	state, lookahead, errflag, done;
	int	rule, npop;
	short	* states;
	int	nstates;
	YYSTYPE * values;
	int	nvalues;
	short	* types;
} yyTraceItems;
#endif


/*
 * Copyright 1985, 1990 by Mortice Kern Systems Inc.  All rights reserved.
 * 
 * Automaton to interpret LALR(1) tables.
 *
 * Macros:
 *	yyclearin - clear the lookahead token.
 *	yyerrok - forgive a pending error
 *	YYERROR - simulate an error
 *	YYACCEPT - halt and return 0
 *	YYABORT - halt and return 1
 *	YYRETURN(value) - halt and return value.  You should use this
 *		instead of return(value).
 *	YYREAD - ensure yychar contains a lookahead token by reading
 *		one if it does not.  See also YYSYNC.
 *	YYRECOVERING - 1 if syntax error detected and not recovered
 *		yet; otherwise, 0.
 *
 * Preprocessor flags:
 *	YYDEBUG - includes debug code if 1.  The parser will print
 *		 a travelogue of the parse if this is defined as 1
 *		 and yydebug is non-zero.
 *		yacc -t sets YYDEBUG to 1, but not yydebug.
 *	YYTRACE - turn on YYDEBUG, and undefine default trace functions
 *		so that the interactive functions in 'ytrack.c' will
 *		be used.
 *	YYSSIZE - size of state and value stacks (default 150).
 *	YYSTATIC - By default, the state stack is an automatic array.
 *		If this is defined, the stack will be static.
 *		In either case, the value stack is static.
 *	YYALLOC - Dynamically allocate both the state and value stacks
 *		by calling malloc() and free().
 *	YYDYNAMIC - Dynamically allocate (and reallocate, if necessary)
 *		both the state and value stacks by calling malloc(),
 *		realloc(), and free().
 *	YYSYNC - if defined, yacc guarantees to fetch a lookahead token
 *		before any action, even if it doesnt need it for a decision.
 *		If YYSYNC is defined, YYREAD will never be necessary unless
 *		the user explicitly sets yychar = -1
 *
 * Copyright (c) 1983, by the University of Waterloo
 */
/*
 * Prototypes
 */

extern int yylex YY_ARGS((void));

#if YYDEBUG

#include <stdlib.h>		/* common prototypes */
#include <string.h>

extern char *	yyValue YY_ARGS((YYSTYPE, int));	/* print yylval */
extern void yyShowState YY_ARGS((yyTraceItems *));
extern void yyShowReduce YY_ARGS((yyTraceItems *));
extern void yyShowGoto YY_ARGS((yyTraceItems *));
extern void yyShowShift YY_ARGS((yyTraceItems *));
extern void yyShowErrRecovery YY_ARGS((yyTraceItems *));
extern void yyShowErrDiscard YY_ARGS((yyTraceItems *));

extern void yyShowRead YY_ARGS((int));
#endif

/*
 * If YYDEBUG defined and yydebug set,
 * tracing functions will be called at appropriate times in yyparse()
 * Pass state of YACC parse, as filled into yyTraceItems yyx
 * If yyx.done is set by the tracing function, yyparse() will terminate
 * with a return value of -1
 */
#define YY_TRACE(fn) { \
	yyx.state = yystate; yyx.lookahead = yychar; yyx.errflag =yyerrflag; \
	yyx.states = yys+1; yyx.nstates = yyps-yys; \
	yyx.values = yyv+1; yyx.nvalues = yypv-yyv; \
	yyx.types = yytypev+1; yyx.done = 0; \
	yyx.rule = yyi; yyx.npop = yyj; \
	fn(&yyx); \
	if (yyx.done) YYRETURN(-1); }

#ifndef I18N
#define m_textmsg(id, str, cls)	(str)
#else /*I18N*/
#include <m_nls.h>
#endif/*I18N*/

#ifndef YYSSIZE
# define YYSSIZE	150
#endif

#ifdef YYDYNAMIC
#define YYALLOC
char *getenv();
int atoi();
int yysinc = -1; /* stack size increment, <0 = double, 0 = none, >0 = fixed */
#endif

#ifdef YYALLOC
int yyssize = YYSSIZE;
#endif

#define YYERROR		goto yyerrlabel
#define yyerrok		yyerrflag = 0
#if YYDEBUG
#define yyclearin	{ if (yydebug) yyShowRead(-1); yychar = -1; }
#else
#define yyclearin	yychar = -1
#endif
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRECOVERING()	(yyerrflag != 0)
#ifdef YYALLOC
#define YYRETURN(val)	{ retval = (val); goto yyReturn; }
#else
#define YYRETURN(val)	return(val);
#endif
#if YYDEBUG
/* The if..else makes this macro behave exactly like a statement */
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0)	{		\
				if (yychar == -2) YYABORT; \
				yychar = 0;				\
			}	/* endif */			\
			if (yydebug)					\
				yyShowRead(yychar);			\
		} else
#else
# define YYREAD	if (yychar < 0) {					\
			if ((yychar = yylex()) < 0) {			\
				if (yychar == -2) YYABORT; \
				yychar = 0;				\
			}	/* endif */			\
		} else
#endif

#define YYERRCODE	256		/* value of `error' */
#define	YYQYYP	yyq[yyq-yyp]

YYSTYPE	yyval;				/* $ */
YYSTYPE	*yypvt;				/* $n */
YYSTYPE	yylval;				/* yylex() sets this */

int	yychar,				/* current token */
	yyerrflag,			/* error flag */
	yynerrs;			/* error count */

#if YYDEBUG
int yydebug = 0;		/* debug if this flag is set */
extern char	*yysvar[];	/* table of non-terminals (aka 'variables') */
extern yyNamedType yyTokenTypes[];	/* table of terminals & their types */
extern short	yyrmap[], yysmap[];	/* map internal rule/states */
extern int	yynstate, yynvar, yyntoken, yynrule;

extern int	yyGetType YY_ARGS((int));	/* token type */
extern char	*yyptok YY_ARGS((int));	/* printable token string */
extern int	yyExpandName YY_ARGS((int, int, char *, int));
				  /* expand yyRules[] or yyStates[] */
static char *	yygetState YY_ARGS((int));

#define yyassert(condition, msg, arg) \
	if (!(condition)) { \
		printf(m_textmsg(2824, "\nyacc bug: ", "E")); \
		printf(msg, arg); \
		YYABORT; }
#else /* !YYDEBUG */
#define yyassert(condition, msg, arg)
#endif



#ifdef YACC_WINDOWS

/*
 * the following is the yyparse() function that will be
 * callable by a windows type program. It in turn will
 * load all needed resources, obtain pointers to these
 * resources, and call a statically defined function
 * win_yyparse(), which is the original yyparse() fn
 * When win_yyparse() is complete, it will return a
 * value to the new yyparse(), where it will be stored
 * away temporarily, all resources will be freed, and
 * that return value will be given back to the caller
 * yyparse(), as expected.
 */

static int win_yyparse();			/* prototype */

yyparse() 
{
	int wReturnValue;
	HANDLE hRes_table;		/* handle of resource after loading */
	short *old_yydef;		/* the following are used for saving */
	short *old_yyex;		/* the current pointers */
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	/*
	 * the following code will load the required
	 * resources for a Windows based parser.
	 */

	hRes_table = LoadResource (hInst, 
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	/*
	 * return an error code if any
	 * of the resources did not load
	 */

	if (hRes_table == NULL)
		return (1);
	
	/*
	 * the following code will lock the resources
	 * into fixed memory locations for the parser
	 * (also, save the current pointer values first)
	 */

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	/*
	 * call the official yyparse() function
	 */

	wReturnValue = win_yyparse();

	/*
	 * unlock the resources
	 */

	UnlockResource (hRes_table);

	/*
	 * and now free the resource
	 */

	FreeResource (hRes_table);

	/*
	 * restore previous pointer values
	 */

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	/* end yyparse */

static int win_yyparse() 

#else /* YACC_WINDOWS */

/*
 * we are not compiling a windows resource
 * based parser, so call yyparse() the old
 * standard way.
 */

yyparse() 

#endif /* YACC_WINDOWS */

{
	register short		yyi, *yyp;	/* for table lookup */
	register short		*yyps;		/* top of state stack */
	register short		yystate;	/* current state */
	register YYSTYPE	*yypv;		/* top of value stack */
	register short		*yyq;
	register int		yyj;
#if YYDEBUG
	yyTraceItems	yyx;			/* trace block */
	short	* yytp;
	int	yyruletype = 0;
#endif
#ifdef YYSTATIC
	static short	yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];
#if YYDEBUG
	static short	yytypev[YYSSIZE+1];	/* type assignments */
#endif
#else /* ! YYSTATIC */
#ifdef YYALLOC
	YYSTYPE *yyv;
	short	*yys;
#if YYDEBUG
	short	*yytypev;
#endif
	YYSTYPE save_yylval;
	YYSTYPE save_yyval;
	YYSTYPE *save_yypvt;
	int save_yychar, save_yyerrflag, save_yynerrs;
	int retval; 			/* return value holder */
#else
	short		yys[YYSSIZE + 1];
	static YYSTYPE	yyv[YYSSIZE + 1];	/* historically static */
#if YYDEBUG
	short	yytypev[YYSSIZE+1];		/* mirror type table */
#endif
#endif /* ! YYALLOC */
#endif /* ! YYSTATIC */
#ifdef YYDYNAMIC
	char *envp;
#endif


#ifdef YYDYNAMIC
	if ((envp = getenv("YYSTACKSIZE")) != (char *)0) {
		yyssize = atoi(envp);
		if (yyssize <= 0)
			yyssize = YYSSIZE;
	}
	if ((envp = getenv("YYSTACKINC")) != (char *)0)
		yysinc = atoi(envp);
#endif
#ifdef YYALLOC
	yys = (short *) malloc((yyssize + 1) * sizeof(short));
	yyv = (YYSTYPE *) malloc((yyssize + 1) * sizeof(YYSTYPE));
#if YYDEBUG
	yytypev = (short *) malloc((yyssize + 1) * sizeof(short));
#endif
	if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
		|| yytypev == (short *) 0
#endif
	) {
		yyerror("Not enough space for parser stacks");
		return 1;
	}
	save_yylval = yylval;
	save_yyval = yyval;
	save_yypvt = yypvt;
	save_yychar = yychar;
	save_yyerrflag = yyerrflag;
	save_yynerrs = yynerrs;
#endif

	yynerrs = 0;
	yyerrflag = 0;
	yyclearin;
	yyps = yys;
	yypv = yyv;
	*yyps = yystate = YYS0;		/* start state */
#if YYDEBUG
	yytp = yytypev;
	yyi = yyj = 0;			/* silence compiler warnings */
#endif

yyStack:
	yyassert((unsigned)yystate < yynstate, m_textmsg(587, "state %d\n", ""), yystate);
#ifdef YYDYNAMIC
	if (++yyps > &yys[yyssize]) {
		int yynewsize;
		int yysindex = yyps - yys;
		int yyvindex = yypv - yyv;
#if YYDEBUG
		int yytindex = yytp - yytypev;
#endif
		if (yysinc == 0) {		/* no increment */
			yyerror("Parser stack overflow");
			YYABORT;
		} else if (yysinc < 0)		/* binary-exponential */
			yynewsize = yyssize * 2;
		else				/* fixed increment */
			yynewsize = yyssize + yysinc;
		if (yynewsize < yyssize) {
			yyerror("Not enough space for parser stacks");
			YYABORT;
		}
		yyssize = yynewsize;
		yys = (short *) realloc(yys, (yyssize + 1) * sizeof(short));
		yyps = yys + yysindex;
		yyv = (YYSTYPE *) realloc(yyv, (yyssize + 1) * sizeof(YYSTYPE));
		yypv = yyv + yyvindex;
#if YYDEBUG
		yytypev = (short *)realloc(yytypev,(yyssize + 1)*sizeof(short));
		yytp = yytypev + yytindex;
#endif
		if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
			|| yytypev == (short *) 0
#endif
		) {
			yyerror("Not enough space for parser stacks");
			YYABORT;
		}
	}
#else
	if (++yyps > &yys[YYSSIZE]) {
		yyerror("Parser stack overflow");
		YYABORT;
	}
#endif /* !YYDYNAMIC */
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	*++yytp = yyruletype;	/* ... and type */

	if (yydebug)
		YY_TRACE(yyShowState)
#endif

	/*
	 *	Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	YYREAD;
#endif

#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			YYREAD;
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~YYQYYP;
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;	/* stack what yylex() set */
				yyclearin;		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef)
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */
			/* Search exception table */
#ifdef YACC_WINDOWS
			yyassert((unsigned)~yyi < Sizeof_yyex,
				m_textmsg(2825, "exception %d\n", "I num"), yystate);
#else /* YACC_WINDOWS */
			yyassert((unsigned)~yyi < sizeof yyex/sizeof yyex[0],
				m_textmsg(2825, "exception %d\n", "I num"), yystate);
#endif /* YACC_WINDOWS */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			YYREAD;
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
			yyassert(yyi >= 0,
				 m_textmsg(2826, "Ex table not reduce %d\n", "I num"), yyi);
		}
	}

	yyassert((unsigned)yyi < yynrule, m_textmsg(2827, "reduce %d\n", "I num"), yyi);
	yyj = yyrlen[yyi];
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowReduce)
	yytp -= yyj;
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	yyruletype = yyRules[yyrmap[yyi]].type;
#endif

	switch (yyi) {		/* perform semantic action */
		
case YYr1: {	/* primary_expr :  identifier */
 yyval.np = eval_ident(yypvt[0].sp); 
} break;

case YYr2: {	/* primary_expr :  INT_LITERAL */
 yyval.np = leafi(INT_LITERAL, yypvt[0].ival); 
} break;

case YYr3: {	/* primary_expr :  DOUBLE_LITERAL */
 yyval.np = leafd(DOUBLE_LITERAL, yypvt[0].dval); 
} break;

case YYr4: {	/* primary_expr :  BIT_LITERAL */
 yyval.np = leafi(INT_LITERAL, yypvt[0].bit->val); free(yypvt[0].bit); 
} break;

case YYr5: {	/* primary_expr :  '(' assignment_expr ')' */
 yyval.np = yypvt[-1].np; yyval.np->paren = 1; 
} break;

case YYr8: {	/* postfix_expr :  postfix_expr '[' assignment_expr ']' */
 yyval.np = eval_subarray(yypvt[-3].np, yypvt[-1].np); 
} break;

case YYr9: {	/* postfix_expr :  rescoped_expr identifier */
 
        yyval.np = eval_scoped(yypvt[-1].np, yypvt[0].sp);

        
        s_remcontext();
        s_remcontext();
    
} break;

case YYr10: {	/* postfix_expr :  postfix_expr INC */
 yyval.np = eval_incdec(yypvt[0].ival, yypvt[-1].np); 
} break;

case YYr11: {	/* postfix_expr :  postfix_expr DEC */
 yyval.np = eval_incdec(yypvt[0].ival, yypvt[-1].np); 
} break;

case YYr12: {	/* rescoped_expr :  postfix_expr '.' */

        
        if (yypvt[-1].np->ptype!=NULL && yypvt[-1].np->ptype->cxt!=NULL) s_inscontext(yypvt[-1].np->ptype->cxt);
        
        s_newcontext(0);
        yyval.np = yypvt[-1].np;
    
} break;

case YYr14: {	/* unary_expr :  postfix_expr */
 yyval.np = eval_array(yypvt[0].np); 
} break;

case YYr15: {	/* unary_expr :  unary_operator unary_expr */
 yyval.np = eval_unary(yypvt[-1].ival, yypvt[0].np); 
} break;

case YYr16: {	/* builtin_function :  LENGTHOF '(' postfix_expr ')' */
 yyval.np = eval_lengthof(eval_array(yypvt[-1].np)); 
} break;

case YYr17: {	/* builtin_function :  ISIDOF '(' CLASS_TYPE ',' assignment_expr ')' */
 yyval.np = eval_isidof(yypvt[-3].sp, yypvt[-1].np); 
} break;

case YYr18: {	/* builtin_function :  SKIPBITS '(' assignment_expr ')' */
 yyval.np = eval_skipbits(yypvt[-1].np); 
} break;

case YYr20: {	/* builtin_function :  NEXTCODE '(' BIT_LITERAL ')' */
 
        yyval.np = node(NEXTCODE, leafb(BIT_LITERAL, yypvt[-1].bit), NULL);
        yyval.np->type=INT; yyval.np->ptype = s_lookup("int"); 
    
} break;

case YYr21: {	/* builtin_function :  NEXTCODE '(' alignment_modifier ',' BIT_LITERAL ')' */
 
        yyval.np=node(NEXTCODE, leafb(BIT_LITERAL, yypvt[-1].bit), yypvt[-3].np);
        yyval.np->type = INT; yyval.np->ptype = s_lookup("int"); 
    
} break;

case YYr22: {	/* builtin_function :  NUMBITS '(' ')' */
 yyval.np = leaf(NUMBITS); yyval.np->type = INT; yyval.np->ptype = s_lookup("int"); 
} break;

case YYr23: {	/* nextbits_function :  NEXTBITS '(' assignment_expr ')' */
 yyval.np = eval_nextbits(yypvt[-1].np, 0, NULL); 
} break;

case YYr24: {	/* nextbits_function :  NEXTBITS '(' modifier_list ',' assignment_expr ')' */
 yyval.np = eval_nextbits(yypvt[-1].np, yypvt[-3].ival, NULL); 
} break;

case YYr25: {	/* nextbits_function :  NEXTBITS '(' alignment_modifier ',' assignment_expr ')' */
 yyval.np = eval_nextbits(yypvt[-1].np, 0, yypvt[-3].np); 
} break;

case YYr26: {	/* nextbits_function :  NEXTBITS '(' alignment_modifier ',' modifier_list ',' assignment_expr ')' */
 yyval.np = eval_nextbits(yypvt[-1].np, yypvt[-3].ival, yypvt[-5].np); 
} break;

case YYr27: {	/* modifier_list :  modifier */
 yyval.ival = s_tok2mod(yypvt[0].ival); 
} break;

case YYr28: {	/* modifier_list :  modifier_list ',' modifier */
 yyval.ival = check_mod(yypvt[-2].ival, s_tok2mod(yypvt[0].ival)); 
} break;

case YYr36: {	/* multiplicative_expr :  multiplicative_expr '*' unary_expr */
 yyval.np = eval_mult(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr37: {	/* multiplicative_expr :  multiplicative_expr '/' unary_expr */
 yyval.np = eval_mult(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr38: {	/* multiplicative_expr :  multiplicative_expr '%' unary_expr */
 yyval.np = eval_mult(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr40: {	/* additive_expr :  additive_expr '+' multiplicative_expr */
 yyval.np = eval_add(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr41: {	/* additive_expr :  additive_expr '-' multiplicative_expr */
 yyval.np = eval_add(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr43: {	/* shift_expr :  shift_expr LS additive_expr */
 yyval.np = eval_shift(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr44: {	/* shift_expr :  shift_expr RS additive_expr */
 yyval.np = eval_shift(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr45: {	/* shift_expr :  shift_expr '&' additive_expr */
 yyval.np = eval_shift(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr46: {	/* shift_expr :  shift_expr '^' additive_expr */
 yyval.np = eval_shift(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr47: {	/* shift_expr :  shift_expr '|' additive_expr */
 yyval.np = eval_shift(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr49: {	/* relational_expr :  relational_expr '<' shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr50: {	/* relational_expr :  relational_expr '>' shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr51: {	/* relational_expr :  relational_expr LE shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr52: {	/* relational_expr :  relational_expr GE shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr53: {	/* relational_expr :  relational_expr EQ shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr54: {	/* relational_expr :  relational_expr NE shift_expr */
 yyval.np = eval_rel(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr56: {	/* logical_and_expr :  logical_and_expr AND relational_expr */
 yyval.np = eval_logic(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr57: {	/* logical_or_expr :  logical_and_expr */
 yyval.np = check_unassigned(yypvt[0].np, yypvt[0].np); 
} break;

case YYr58: {	/* logical_or_expr :  logical_or_expr OR logical_and_expr */
 yyval.np = eval_logic(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr60: {	/* conditional_expr :  logical_or_expr '?' conditional_expr ':' conditional_expr */
 yyval.np = eval_cond(yypvt[-3].ival, yypvt[-4].np, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr62: {	/* assignment_expr :  unary_expr assignment_operator assignment_expr */
 yyval.np = check_assign(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr75: {	/* assignment_expr_list :  assignment_expr_list ',' assignment_expr */
 yyval.np = node(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr77: {	/* argument_expr_list :  assignment_expr ',' argument_expr_list */
 yyval.np = node(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
} break;

case YYr79: {	/* declaration_list :  type_info init_declarator */

        yyval.lp = yypvt[0].lp;

        
        yyval.lp->e2 = check_parse(yypvt[-1].lp->sp, yypvt[-1].lp->type, yypvt[-1].lp->e1);
        
        
        if (yypvt[-1].lp->usenext && yypvt[-1].lp->e1->op == MAP_TYPE && yypvt[-1].lp->e1->left.sp->escape)
            yyerror("Map with escape (%s) cannot be used in lookahead parsing", yypvt[-1].lp->e1->left.sp->name);

        
        if (yypvt[-1].lp->e1 && yypvt[-1].lp->e1->op == BAC_TYPE) 
            if (yypvt[0].lp == NULL || yypvt[0].lp->e3 == NULL)
                yyerror("BAC (%s) must be accompanied with corresponding parameters", yypvt[-1].lp->e1->left.sp->name);
        
        yyval.lp->align = yypvt[-1].lp->align;
        yyval.lp->usenext = yypvt[-1].lp->usenext;
        
        
        if (yypvt[-1].lp->sp->ident == BIT) yypvt[-1].lp->type |= M_UNSIGNED;
        
        
        yyval.lp->sp = set_var(yyval.lp->sp, yypvt[-1].lp->sp, yypvt[-1].lp->type, yypvt[0].lp->e2, yypvt[0].lp->e1, yypvt[0].lp->e3, yypvt[-1].lp->align, yypvt[0].lp->dims, yypvt[0].lp->dim, 0, yyval.lp->sp->range);
        
        
        if (yypvt[0].lp->e1 != NULL && yypvt[0].lp->e1->op == ARRAY && yypvt[0].lp->sp->cxt_level > 0)
            yyval.lp = c_array_unroll(yyval.lp); 
    
} break;

case YYr80: {	/* declaration_list :  declaration_list ',' init_declarator */

        
        yypvt[0].lp->e2 = yypvt[-2].lp->e2;
        yypvt[0].lp->align = yypvt[-2].lp->align;
        yypvt[0].lp->usenext = yypvt[-2].lp->usenext;
 
        
        yypvt[0].lp->sp = set_var(yypvt[0].lp->sp, yypvt[-2].lp->sp->ptype, yypvt[-2].lp->sp->modifiers, yypvt[0].lp->e2, yypvt[0].lp->e1, yypvt[0].lp->e3, yypvt[-2].lp->align, yypvt[0].lp->dims, yypvt[0].lp->dim, 0, yypvt[0].lp->sp->range);
 
        
        if (yypvt[0].lp->e1 != NULL && yypvt[0].lp->e1->op == ARRAY && yypvt[0].lp->sp->cxt_level > 0)
            yyval.lp = app(yypvt[-2].lp, c_array_unroll(yypvt[0].lp)); 
        else
            yyval.lp = app(yypvt[-2].lp, yypvt[0].lp);
    
} break;

case YYr81: {	/* type_info :  alignment_modifier plain_type_info */
 yypvt[0].lp->align = yypvt[-1].np; yyval.lp = yypvt[0].lp; 
} break;

case YYr82: {	/* type_info :  alignment_modifier parsable_type_info */
 yypvt[0].lp->align = yypvt[-1].np; yyval.lp = yypvt[0].lp; 
} break;

case YYr83: {	/* plain_type_info :  type_specifier */
 yyval.lp = lnew_type(M_NONE, yypvt[0].sp, NULL, 0); 
} break;

case YYr84: {	/* plain_type_info :  declaration_modifiers */

        if (!(yypvt[0].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified");
        yyval.lp = lnew_type(check_modtype(yypvt[0].ival, s_lookup("int")), s_lookup("int"), NULL, 0);
    
} break;

case YYr85: {	/* plain_type_info :  declaration_modifiers type_specifier */

        yyval.lp = lnew_type(check_modtype(yypvt[-1].ival, yypvt[0].sp), yypvt[0].sp, NULL, 0);
    
} break;

case YYr86: {	/* parsable_type_info :  builtin_type_specifier '(' conditional_expr ')' */
 yyval.lp = lnew_type(M_NONE, yypvt[-3].sp, yypvt[-1].np, 0); 
} break;

case YYr87: {	/* parsable_type_info :  builtin_type_specifier '(' MAP_TYPE ')' */
 yyval.lp = lnew_type(M_NONE, yypvt[-3].sp, leafs(MAP_TYPE, yypvt[-1].sp), 0); 
} break;

case YYr88: {	/* parsable_type_info :  user_type_specifier '(' MAP_TYPE ')' */
 yyval.lp = lnew_type(M_NONE, yypvt[-3].sp, leafs(MAP_TYPE, yypvt[-1].sp), 0); 
} break;

case YYr89: {	/* parsable_type_info :  builtin_type_specifier '(' conditional_expr ')' '*' */
 yyval.lp = lnew_type(M_NONE, yypvt[-4].sp, yypvt[-2].np, 1); 
} break;

case YYr90: {	/* parsable_type_info :  builtin_type_specifier '(' MAP_TYPE ')' '*' */
 yyval.lp = lnew_type(M_NONE, yypvt[-4].sp, leafs(MAP_TYPE, yypvt[-2].sp), 1); 
} break;

case YYr91: {	/* parsable_type_info :  user_type_specifier '(' MAP_TYPE ')' '*' */
 yyval.lp = lnew_type(M_NONE, yypvt[-4].sp, leafs(MAP_TYPE, yypvt[-2].sp), 1); 
} break;

case YYr92: {	/* parsable_type_info :  declaration_modifiers '(' conditional_expr ')' */

        if (!(yypvt[-3].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified");
        yyval.lp = lnew_type(check_modtype(yypvt[-3].ival, s_lookup("int")), s_lookup("int"), yypvt[-1].np, 0);
    
} break;

case YYr93: {	/* parsable_type_info :  declaration_modifiers '(' MAP_TYPE ')' */

        if (!(yypvt[-3].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified");
        yyval.lp = lnew_type(check_modtype(yypvt[-3].ival, s_lookup("int")), s_lookup("int"), leafs(MAP_TYPE, yypvt[-1].sp), 0);
    
} break;

case YYr94: {	/* parsable_type_info :  declaration_modifiers '(' conditional_expr ')' '*' */

        if (!(yypvt[-4].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified");
        yyval.lp = lnew_type(check_modtype(yypvt[-4].ival, s_lookup("int")), s_lookup("int"), yypvt[-2].np, 1);
    
} break;

case YYr95: {	/* parsable_type_info :  declaration_modifiers '(' MAP_TYPE ')' '*' */

        if (!(yypvt[-4].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified");
        yyval.lp = lnew_type(check_modtype(yypvt[-4].ival, s_lookup("int")), s_lookup("int"), leafs(MAP_TYPE, yypvt[-2].sp), 1);
    
} break;

case YYr96: {	/* parsable_type_info :  declaration_modifiers builtin_type_specifier '(' conditional_expr ')' */

        yyval.lp = lnew_type(check_modtype(yypvt[-4].ival, yypvt[-3].sp), yypvt[-3].sp, yypvt[-1].np, 0);
    
} break;

case YYr97: {	/* parsable_type_info :  declaration_modifiers builtin_type_specifier '(' MAP_TYPE ')' */

        yyval.lp = lnew_type(check_modtype(yypvt[-4].ival, yypvt[-3].sp), yypvt[-3].sp, leafs(MAP_TYPE, yypvt[-1].sp), 0);
    
} break;

case YYr98: {	/* parsable_type_info :  declaration_modifiers builtin_type_specifier '(' conditional_expr ')' '*' */

        yyval.lp = lnew_type(check_modtype(yypvt[-5].ival, yypvt[-4].sp), yypvt[-4].sp, yypvt[-2].np, 1);
    
} break;

case YYr99: {	/* parsable_type_info :  declaration_modifiers builtin_type_specifier '(' MAP_TYPE ')' '*' */

        yyval.lp = lnew_type(check_modtype(yypvt[-5].ival, yypvt[-4].sp), yypvt[-4].sp, leafs(MAP_TYPE, yypvt[-2].sp), 1);
    
} break;

case YYr100: {	/* parsable_type_info :  builtin_type_specifier '(' BAC_TYPE ')' */

        yyval.lp = lnew_type(M_NONE, yypvt[-3].sp, leafs(BAC_TYPE, yypvt[-1].sp), 0);
    
} break;

case YYr101: {	/* declaration_modifiers :  modifier */
 yyval.ival = s_tok2mod(yypvt[0].ival); 
} break;

case YYr102: {	/* declaration_modifiers :  declaration_modifiers modifier */
 yyval.ival = check_mod(yypvt[-1].ival, s_tok2mod(yypvt[0].ival)); 
} break;

case YYr110: {	/* alignment_modifier :  */
 yyval.np = NULL; 
} break;

case YYr111: {	/* alignment_modifier :  ALIGNED */
 yyval.np = leafi(INT_LITERAL, 8); 
} break;

case YYr112: {	/* alignment_modifier :  ALIGNED '(' conditional_expr ')' */
 yyval.np = check_align_arg(yypvt[-1].np); 
} break;

case YYr120: {	/* user_type_specifier :  CLASS_TYPE */

        if (w_cyclic && s_get_cur_class() == yypvt[0].sp) 
            yyerror("Declaration creates cyclic reference in class '%s'", yypvt[0].sp->name);
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr122: {	/* init_declarator :  declarator '=' assignment_expr */
   
        yypvt[-2].lp->sp->assigned = 1;
        yypvt[-2].lp->e1 = yypvt[0].np;
        yyval.lp = yypvt[-2].lp;
    
} break;

case YYr123: {	/* init_declarator :  declarator '=' array */

        yypvt[-2].lp->sp->assigned = 1;
        yypvt[-2].lp->e1 = yypvt[0].np;
        yyval.lp = yypvt[-2].lp;
    
} break;

case YYr126: {	/* array :  '{' array_expr_list '}' */
 
        yyval.np = node(ARRAY, yypvt[-1].np, NULL); 
        yyval.np->ptype = yypvt[-1].np->ptype;
        yyval.np->type = yypvt[-1].np->type;
    
} break;

case YYr127: {	/* array :  STRING_LITERAL */

        yyval.np = node(ARRAY, eval_array_string(yypvt[0].string), NULL);
        yyval.np->ptype = s_lookup("char");
        yyval.np->type = CHAR;
    
} break;

case YYr129: {	/* array_expr_list :  array_expr_list ',' array_expr */
 
        yyval.np = node(yypvt[-1].ival, yypvt[-2].np, yypvt[0].np); 
        yyval.np->ptype = check_type_promote(yypvt[-2].np->ptype, yypvt[0].np->ptype);
        yyval.np->type = yyval.np->ptype->ident;
    
} break;

case YYr132: {	/* declarator :  identifier */
 yyval.lp = lnew_sp(DECL, yypvt[0].sp); 
} break;

case YYr133: {	/* declarator :  declarator '[' assignment_expr ']' */

        
        s_cur_class_dimx_nonpartial(yypvt[-3].lp->dims, 1);
        yypvt[-3].lp->dims++;
        yypvt[-3].lp->dim = (node_t **)buildarray((void **)yypvt[-3].lp->dim, node(yypvt[-2].ival, check_array_size(yypvt[-1].np), NULL));
        yyval.lp = yypvt[-3].lp;
    
} break;

case YYr134: {	/* declarator :  declarator '[' '[' assignment_expr ']' ']' */

        s_cur_class_dimx_nonpartial(yypvt[-5].lp->dims, 0);
        yypvt[-5].lp->dims++;
        yypvt[-5].lp->dim = (node_t **)buildarray((void **)yypvt[-5].lp->dim, node(DBL_BRACE_L, check_array_index(yypvt[-2].np), NULL));
        yyval.lp = yypvt[-5].lp;
    
} break;

case YYr135: {	/* declarator_with_params :  declarator '(' argument_expr_list ')' */

        
        yypvt[-3].lp->e3 = yypvt[-1].np;
        yyval.lp = yypvt[-3].lp;
    
} break;

case YYr136: {	/* declarator_with_range :  declarator '=' conditional_expr RANGE conditional_expr */

        yypvt[-4].lp->sp->range = 1;
        yypvt[-4].lp->sp->assigned = 1;
        yypvt[-4].lp->e1 = idrange(yypvt[-2].np, yypvt[0].np);
        yyval.lp = yypvt[-4].lp;   
    
} break;

case YYr144: {	/* labeled_statement :  identifier ':' statement_or_declaration */
 
        if (yypvt[-2].sp->ptype != NULL) yyerror("Use of variable '%s' as a label is illegal", yypvt[-2].sp->name);
        yypvt[-2].sp->ident = LABEL;
        yyval.lp = prep(yypvt[0].lp, lnew_sp(LABEL, yypvt[-2].sp));
    
} break;

case YYr145: {	/* labeled_statement :  CASE conditional_expr ':' statement_or_declaration */

        if (yypvt[-2].np->type > INT) yyerror("The 'case' expression must be of integral type");
        if (!is_literal(yypvt[-2].np->op) || (yypvt[-2].np->op == VARIABLE && !(yypvt[-2].np->left.sp->modifiers & M_CONST))) yyerror("The 'case' expression must be a constant");
        yyval.lp = lnews1(yypvt[-3].ival, yypvt[-2].np, yypvt[0].lp);
    
} break;

case YYr146: {	/* labeled_statement :  DEFAULT ':' statement_or_declaration */
 yyval.lp = lnews0(yypvt[-2].ival, yypvt[0].lp); 
} break;

case YYr147: {	/* compound_statement :  '{' '}' */
 yyval.lp = lnew0(yypvt[-1].ival); 
} break;

case YYr148: {	/* compound_statement :  '{' statement_or_declaration_list '}' */
 yyval.lp = lnews0(yypvt[-2].ival, yypvt[-1].lp); 
} break;

case YYr150: {	/* statement_or_declaration_list :  statement_or_declaration_list statement_or_declaration */
 yyval.lp = app(yypvt[-1].lp, yypvt[0].lp); 
} break;

case YYr157: {	/* expression_statement :  ';' */
 yyval.lp = lnew0(EXPR); 
} break;

case YYr158: {	/* expression_statement :  assignment_expr ';' */
 yyval.lp = lnew1(EXPR, yypvt[-1].np); 
} break;

case YYr159: {	/* selection_statement :  IF '(' logical_or_expr ')' statement_or_declaration */
 yyval.lp = lnew_ifelse(yypvt[-2].np, yypvt[0].lp, NULL); 
} break;

case YYr160: {	/* selection_statement :  IF '(' logical_or_expr ')' statement_or_declaration ELSE statement_or_declaration */
 yyval.lp = lnew_ifelse(yypvt[-4].np, yypvt[-2].lp, yypvt[0].lp); 
} break;

case YYr161: {	/* selection_statement :  SWITCH '(' assignment_expr ')' statement_or_declaration */

        if (yypvt[-2].np->type>INT) yyerror("'switch' expression must be of integral type");
        yyval.lp = lnews1(yypvt[-4].ival, yypvt[-2].np, yypvt[0].lp);
    
} break;

case YYr162: {	/* iteration_statement :  WHILE '(' logical_or_expr ')' statement_or_declaration */
 yyval.lp = lnews1(yypvt[-4].ival, yypvt[-2].np, yypvt[0].lp); 
} break;

case YYr163: {	/* iteration_statement :  DO statement_or_declaration WHILE '(' logical_or_expr ')' ';' */
 yyval.lp = lnews1(yypvt[-6].ival, yypvt[-2].np, yypvt[-5].lp); 
} break;

case YYr164: {	/* iteration_statement :  FOR '(' ';' ';' ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-5].ival, NULL, NULL, NULL, yypvt[0].lp); 
} break;

case YYr165: {	/* iteration_statement :  FOR '(' ';' ';' assignment_expr_list ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-6].ival, NULL, NULL, yypvt[-2].np,   yypvt[0].lp); 
} break;

case YYr166: {	/* iteration_statement :  FOR '(' ';' logical_or_expr ';' ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-6].ival, NULL, yypvt[-3].np,   NULL, yypvt[0].lp); 
} break;

case YYr167: {	/* iteration_statement :  FOR '(' ';' logical_or_expr ';' assignment_expr_list ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-7].ival, NULL, yypvt[-4].np,   yypvt[-2].np,   yypvt[0].lp); 
} break;

case YYr168: {	/* iteration_statement :  FOR '(' assignment_expr_list ';' ';' ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-6].ival, yypvt[-4].np,   NULL, NULL, yypvt[0].lp); 
} break;

case YYr169: {	/* iteration_statement :  FOR '(' assignment_expr_list ';' ';' assignment_expr_list ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-7].ival, yypvt[-5].np,   NULL, yypvt[-2].np,   yypvt[0].lp); 
} break;

case YYr170: {	/* iteration_statement :  FOR '(' assignment_expr_list ';' logical_or_expr ';' ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-7].ival, yypvt[-5].np,   yypvt[-3].np,   NULL, yypvt[0].lp); 
} break;

case YYr171: {	/* iteration_statement :  FOR '(' assignment_expr_list ';' logical_or_expr ';' assignment_expr_list ')' statement_or_declaration */
 yyval.lp = lnews3(yypvt[-8].ival, yypvt[-6].np,   yypvt[-4].np,   yypvt[-2].np,   yypvt[0].lp); 
} break;

case YYr172: {	/* jump_statement :  GOTO LABEL ';' */
 yyval.lp = lnew_sp(yypvt[-2].ival, yypvt[-1].sp); 
} break;

case YYr173: {	/* jump_statement :  CONTINUE ';' */
 yyval.lp = lnew0(yypvt[-1].ival); 
} break;

case YYr174: {	/* jump_statement :  BREAK ';' */
 yyval.lp = lnew0(yypvt[-1].ival); 
} break;

case YYr175: {	/* program :  external_definition */
 
        
        yyval.lp = parsed_code=app(parsed_code, yypvt[0].lp);
    
} break;

case YYr176: {	/* program :  program external_definition */
 yyval.lp = app(yypvt[-1].lp, yypvt[0].lp); 
} break;

case YYr185: {	/* class_definition :  complex_class_declarator class_body */

        if (yypvt[-1].sp->forward == 1) {
            yypvt[-1].sp->forward = 2; 
            
            if (w_cyclic) check_cyclic_decl_contained(yypvt[-1].sp, yypvt[-1].sp->forwardref);
        }
        
        if (yypvt[-1].sp->align != NULL) yypvt[-1].sp->parsable = 1;

        s_remcontext();         
        s_remcontext();         
        s_set_cur_class(NULL);  
        yyval.lp = lnews_sp(CLASS, yypvt[-1].sp, yypvt[0].lp); 
    
} break;

case YYr186: {	/* class_definition :  complex_class_declarator ';' */

        yypvt[-1].sp->forward = 1;        
        yypvt[-1].sp->parsable = 1;       
        yypvt[-1].sp->accessed--;         
        
        if (yypvt[-1].sp->ptype != NULL) {
            yyerror("Forward declaration of a class cannot use 'extends'");
            fatal("Translation aborted");
        }
        
        if (yypvt[-1].sp->id != NULL) {
            yyerror("Forward declaration of a class cannot use an ID declaration");
            fatal("Translation aborted");
        }
        
        if (yypvt[-1].sp->abstract == 1) {
            yyerror("Forward declaration of a class should not use 'abstract'");
            yypvt[-1].sp->abstract = 0;
        }
        
        if (yypvt[-1].sp->align != NULL) {
            yyerror("Forward declaration of a class should not use 'align'");
            yypvt[-1].sp->align = NULL;
        }
        s_remcontext();         
        s_remcontext();         
        s_set_cur_class(NULL);  
        yyval.lp = lnews_sp(CLASS, yypvt[-1].sp, NULL); 
    
} break;

case YYr187: {	/* complex_class_declarator :  derived_class_declarator */

        if (yypvt[0].sp->abstract && yypvt[0].sp->id==NULL) {
            yyerror("Abstract class '%s' requires an ID", yypvt[0].sp->name);
            yypvt[0].sp->abstract=0;
        }
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr188: {	/* complex_class_declarator :  derived_class_declarator ':' id_declarator */
 
        yypvt[-2].sp->id = yypvt[0].sp;
        s_transfer(yypvt[0].sp, yypvt[-2].sp->cxt);
        if (!yypvt[-2].sp->abstract) check_id(yypvt[-2].sp);
        yyval.sp = yypvt[-2].sp;
    
} break;

case YYr189: {	/* complex_class_declarator :  derived_class_declarator ':' id_range_declarator */
 
        yypvt[-2].sp->id = yypvt[0].sp;
        s_transfer(yypvt[0].sp, yypvt[-2].sp->cxt);
        if (!yypvt[-2].sp->abstract) check_id(yypvt[-2].sp);
        yyval.sp = yypvt[-2].sp;
    
} break;

case YYr191: {	/* derived_class_declarator :  param_class_declarator EXTENDS CLASS_TYPE */
 
        
        if (yypvt[0].sp->forward == 1) {
            yyerror("Forward-declared class '%s' cannot be used as a base class", yypvt[0].sp->name);
            yypvt[0].sp->accessed--; 
        }
        else {
            
            if (w_cyclic) check_cyclic_decl_derived(yypvt[-2].sp, yypvt[0].sp, yypvt[-2].sp->forwardref);
            
            yypvt[-2].sp->ptype = yypvt[0].sp;
            
            yypvt[0].sp->derived = (symbol_t **)buildarray((void **)yypvt[0].sp->derived, yypvt[-2].sp);
            
            yypvt[-2].sp->parsable = yypvt[0].sp->parsable;
            
            if (yypvt[-2].sp->align == NULL) yypvt[-2].sp->align = yypvt[0].sp->align;
            
            s_copy_st(yypvt[0].sp->cxt, yypvt[-2].sp->cxt);
            
            check_formal_params(yypvt[-2].sp, yypvt[-2].sp->param, yypvt[0].sp->param);
        }
        yyval.sp = yypvt[-2].sp;
    
} break;

case YYr192: {	/* derived_class_declarator :  param_class_declarator EXTENDS identifier */

        yyerror("Incorrect base class '%s'", yypvt[0].sp->name);
        yyval.sp = yypvt[-2].sp;
    
} break;

case YYr193: {	/* param_class_declarator :  aligned_class_declarator */

        
        if (yypvt[0].sp->forward == 1 && yypvt[0].sp->param != NULL) {
            yyerror("Class '%s' definition/declaration has no parameters but previous declaration did", yypvt[0].sp->name);
            yypvt[0].sp->param = NULL;
        }
        yyval.sp=yypvt[0].sp;
    
} break;

case YYr194: {	/* param_class_declarator :  aligned_class_declarator '(' parameter_list ')' */

        
        if (yypvt[-3].sp->forward == 1) check_forward_params(yypvt[-3].sp, yypvt[-1].lp, yypvt[-3].sp->param);
        yypvt[-3].sp->param = yypvt[-1].lp; 
        yyval.sp = yypvt[-3].sp; 
    
} break;

case YYr195: {	/* aligned_class_declarator :  alignment_modifier class_declarator */

        yypvt[0].sp->align = yypvt[-1].np;
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr196: {	/* class_declarator :  CLASS identifier */

        
        s_set_cur_class(yypvt[0].sp);
        
        yypvt[0].sp->cxt = s_newcontext(CLASS);
        
        s_newcontext(0);
        yypvt[0].sp->ident = CLASS_TYPE;
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr197: {	/* class_declarator :  ABSTRACT CLASS identifier */

        
        s_set_cur_class(yypvt[0].sp);
        
        yypvt[0].sp->cxt = s_newcontext(CLASS);
        
        s_newcontext(0);
        yypvt[0].sp->ident = CLASS_TYPE;
        yypvt[0].sp->abstract = 1;
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr198: {	/* class_declarator :  CLASS CLASS_TYPE */

        if (yypvt[0].sp->forward != 1) yyerror("Duplicate definition of class '%s'", yypvt[0].sp->name);
        
        s_set_cur_class(yypvt[0].sp);
        
        yypvt[0].sp->cxt = s_newcontext(CLASS);
        
        s_newcontext(0);
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr199: {	/* class_declarator :  ABSTRACT CLASS CLASS_TYPE */

        if (yypvt[0].sp->forward != 1) yyerror("Duplicate definition of class '%s'", yypvt[0].sp->name);
        
        s_set_cur_class(yypvt[0].sp);
        
        yypvt[0].sp->cxt = s_newcontext(CLASS);
        
        s_newcontext(0);
        yypvt[0].sp->abstract = 1;
        yyval.sp = yypvt[0].sp;
    
} break;

case YYr200: {	/* id_declarator :  alignment_modifier builtin_type_specifier '(' conditional_expr ')' identifier '=' conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), yypvt[-6].sp, M_CONST, check_parse(yypvt[-6].sp, M_CONST, yypvt[-4].np), yypvt[0].np, NULL, yypvt[-7].np, 0, NULL, 0, 0);
        yyval.sp->align = yypvt[-7].np;
    
} break;

case YYr201: {	/* id_declarator :  alignment_modifier declaration_modifiers builtin_type_specifier '(' conditional_expr ')' identifier '=' conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), yypvt[-6].sp, check_modtype((yypvt[-7].ival|M_CONST), yypvt[-6].sp), check_parse(yypvt[-6].sp, (yypvt[-7].ival|M_CONST), yypvt[-4].np), yypvt[0].np, NULL, yypvt[-8].np, 0, NULL, 0, 0);	
        yyval.sp->align = yypvt[-8].np;
    
} break;

case YYr202: {	/* id_declarator :  alignment_modifier declaration_modifiers '(' conditional_expr ')' identifier '=' conditional_expr */

        if (!(yypvt[-6].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified for ID variable '%s'", yypvt[-2].sp->name);
        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), s_lookup("int"), check_modtype((yypvt[-6].ival|M_CONST), s_lookup("int")), check_parse(s_lookup("int"), (yypvt[-6].ival|M_CONST), yypvt[-4].np), yypvt[0].np, NULL, yypvt[-7].np, 0, NULL, 0, 0);	
        yyval.sp->align = yypvt[-7].np;
    
} break;

case YYr203: {	/* id_declarator :  alignment_modifier builtin_type_specifier '(' MAP_TYPE ')' identifier '=' conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), yypvt[-6].sp, M_CONST, check_parse(yypvt[-6].sp, M_CONST, leafs(MAP_TYPE, yypvt[-4].sp)), yypvt[0].np, NULL, yypvt[-7].np, 0, NULL, 0, 0);
        yyval.sp->align = yypvt[-7].np;
    
} break;

case YYr204: {	/* id_declarator :  alignment_modifier declaration_modifiers builtin_type_specifier '(' MAP_TYPE ')' identifier '=' conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), yypvt[-6].sp, check_modtype((yypvt[-7].ival|M_CONST), yypvt[-6].sp), check_parse(yypvt[-6].sp, (yypvt[-7].ival|M_CONST), leafs(MAP_TYPE, yypvt[-4].sp)), yypvt[0].np, NULL, yypvt[-8].np, 0, NULL, 0, 0);	
        yyval.sp->align = yypvt[-8].np;
    
} break;

case YYr205: {	/* id_declarator :  alignment_modifier declaration_modifiers '(' MAP_TYPE ')' identifier '=' conditional_expr */

        if (!(yypvt[-6].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified for ID variable '%s'", yypvt[-2].sp->name);
        yyval.sp = set_var(check_rescope_id(yypvt[-2].sp), s_lookup("int"), check_modtype((yypvt[-6].ival|M_CONST), s_lookup("int")), check_parse(s_lookup("int"), (yypvt[-6].ival|M_CONST), leafs(MAP_TYPE, yypvt[-4].sp)), yypvt[0].np, NULL, yypvt[-7].np, 0, NULL, 0, 0);	
        yyval.sp->align = yypvt[-7].np;
    
} break;

case YYr206: {	/* id_range_declarator :  alignment_modifier builtin_type_specifier '(' conditional_expr ')' identifier '=' conditional_expr RANGE conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), yypvt[-8].sp, M_NONE, check_parse(yypvt[-8].sp, M_CONST, yypvt[-6].np), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-9].np, 0, NULL, 0, 1);
        yyval.sp->align = yypvt[-9].np;
    
} break;

case YYr207: {	/* id_range_declarator :  alignment_modifier declaration_modifiers builtin_type_specifier '(' conditional_expr ')' identifier '=' conditional_expr RANGE conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), yypvt[-8].sp, check_modtype(yypvt[-9].ival, yypvt[-8].sp), check_parse(yypvt[-8].sp, (yypvt[-9].ival|M_CONST), yypvt[-6].np), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-10].np, 0, NULL, 0, 1);	
        yyval.sp->align = yypvt[-10].np;
    
} break;

case YYr208: {	/* id_range_declarator :  alignment_modifier declaration_modifiers '(' conditional_expr ')' identifier '=' conditional_expr RANGE conditional_expr */

        if (!(yypvt[-8].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified for ID variable '%s'", yypvt[-4].sp->name);
        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), s_lookup("int"), check_modtype(yypvt[-8].ival, s_lookup("int")), check_parse(s_lookup("int"), (yypvt[-8].ival|M_CONST), yypvt[-6].np), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-9].np, 0, NULL, 0, 1);	
        yyval.sp->align = yypvt[-9].np;
    
} break;

case YYr209: {	/* id_range_declarator :  alignment_modifier builtin_type_specifier '(' MAP_TYPE ')' identifier '=' conditional_expr RANGE conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), yypvt[-8].sp, M_CONST, check_parse(yypvt[-8].sp, M_NONE, leafs(MAP_TYPE, yypvt[-6].sp)), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-9].np, 0, NULL, 0, 1);
        yyval.sp->align = yypvt[-9].np;
    
} break;

case YYr210: {	/* id_range_declarator :  alignment_modifier declaration_modifiers builtin_type_specifier '(' MAP_TYPE ')' identifier '=' conditional_expr RANGE conditional_expr */

        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), yypvt[-8].sp, check_modtype(yypvt[-9].ival, yypvt[-8].sp), check_parse(yypvt[-8].sp, (yypvt[-9].ival|M_CONST), leafs(MAP_TYPE, yypvt[-6].sp)), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-10].np, 0, NULL, 0, 1);	
        yyval.sp->align = yypvt[-10].np;
    
} break;

case YYr211: {	/* id_range_declarator :  alignment_modifier declaration_modifiers '(' MAP_TYPE ')' identifier '=' conditional_expr RANGE conditional_expr */

        if (!(yypvt[-8].ival & (M_SHORT | M_LONG))) yyerror("No storage class specified for ID variable '%s'", yypvt[-4].sp->name);
        yyval.sp = set_var(check_rescope_id(yypvt[-4].sp), s_lookup("int"), check_modtype(yypvt[-8].ival, s_lookup("int")), check_parse(s_lookup("int"), (yypvt[-8].ival|M_CONST), leafs(MAP_TYPE, yypvt[-6].sp)), idrange(yypvt[-2].np, yypvt[0].np), NULL, yypvt[-9].np, 0, NULL, 0, 1);	
        yyval.sp->align = yypvt[-9].np;
    
} break;

case YYr212: {	/* class_body :  '{' statement_or_declaration_list '}' */
 yyval.lp = yypvt[-1].lp; 
} break;

case YYr213: {	/* class_body :  '{' statement_or_declaration_list '}' ';' */
 yyval.lp = yypvt[-2].lp; 
} break;

case YYr214: {	/* class_body :  '{' '}' */
 yyval.lp = NULL; 
} break;

case YYr215: {	/* class_body :  '{' '}' ';' */
 yyval.lp = NULL; 
} break;

case YYr217: {	/* parameter_list :  parameter_list ',' parameter_declaration */
 yyval.lp = app(yypvt[-2].lp, yypvt[0].lp); 
} break;

case YYr218: {	/* parameter_declaration :  plain_type_info declarator */

        
        set_var(yypvt[0].lp->sp, yypvt[-1].lp->sp, yypvt[-1].lp->type, NULL, NULL, NULL, NULL, yypvt[0].lp->dims, yypvt[0].lp->dim, 1, yypvt[0].lp->sp->range);
	
        
        yypvt[0].lp->sp->assigned = 1;
        yypvt[0].lp->sp->isparam =1 ;
        yyval.lp = yypvt[0].lp;
    
} break;

case YYr219: {	/* verbatim :  VERBATIM */
 yyval.lp = lnew_vp(VERBATIM, yypvt[0].vp); 
} break;

case YYr220: {	/* verbatim :  VERBATIM_GET */
 
        if (!s_in_class()) yyerror("Verbatim get() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_GET, yypvt[0].vp);
    
} break;

case YYr221: {	/* verbatim :  VERBATIM_PUT */

        if (!s_in_class()) yyerror("Verbatim put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_PUT, yypvt[0].vp);
    
} break;

case YYr222: {	/* verbatim :  VERBATIM_BOTH */

        if (!s_in_class()) yyerror("Verbatim get()/put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_BOTH, yypvt[0].vp);
    
} break;

case YYr223: {	/* verbatim :  VERBATIM_C */
 yyval.lp = lnew_vp(VERBATIM_C, yypvt[0].vp); 
} break;

case YYr224: {	/* verbatim :  VERBATIM_GET_C */

        if (!s_in_class()) yyerror("Verbatim C++ get() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_GET_C, yypvt[0].vp);
    
} break;

case YYr225: {	/* verbatim :  VERBATIM_PUT_C */

        if (!s_in_class()) yyerror("Verbatim C++ put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_PUT_C, yypvt[0].vp);
    
} break;

case YYr226: {	/* verbatim :  VERBATIM_BOTH_C */

        if (!s_in_class()) yyerror("Verbatim C++ get()/put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_BOTH_C, yypvt[0].vp);
    
} break;

case YYr227: {	/* verbatim :  VERBATIM_C_CPP */

        if (s_in_class()) yyerror("Verbatim C++ code for .cpp file can not be included within a class");
        yyval.lp = lnew_vp(VERBATIM_C_CPP, yypvt[0].vp);
    
} break;

case YYr228: {	/* verbatim :  VERBATIM_J */
 yyval.lp = lnew_vp(VERBATIM_J, yypvt[0].vp); 
} break;

case YYr229: {	/* verbatim :  VERBATIM_GET_J */

        if (!s_in_class()) yyerror("Verbatim Java get() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_GET_J, yypvt[0].vp);
    
} break;

case YYr230: {	/* verbatim :  VERBATIM_PUT_J */

        if (!s_in_class()) yyerror("Verbatim Java put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_PUT_J, yypvt[0].vp);
    
} break;

case YYr231: {	/* verbatim :  VERBATIM_BOTH_J */

        if (!s_in_class()) yyerror("Verbatim Java get()/put() code can only be included within a class");
        yyval.lp = lnew_vp(VERBATIM_BOTH_J, yypvt[0].vp);
    
} break;

case YYr232: {	/* pragma :  PRAGMA */
 yyval.lp = lnew0(PRAGMA); 
} break;

case YYr233: {	/* pragma :  PRAGMA pragma_list */
 yyval.lp = lnews0(PRAGMA, yypvt[0].lp); 
} break;

case YYr235: {	/* pragma_list :  pragma_list ',' pragma_item */
 yyval.lp = app(yypvt[-2].lp, yypvt[0].lp); 
} break;

case YYr236: {	/* pragma_item :  PRAGMA_ARRAY '=' INT_LITERAL */
 
        if (yypvt[0].ival <= 0) yyerror("Negative or zero size for 'array' pragma: %d", yypvt[0].ival);
        else max_array_size = yypvt[0].ival;
        yyval.lp = lnew1(yypvt[-2].ival, leafi(INT_LITERAL, max_array_size));
    
} break;

case YYr237: {	/* pragma_item :  PRAGMA_GET */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr238: {	/* pragma_item :  PRAGMA_NOGET */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr239: {	/* pragma_item :  PRAGMA_PUT */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr240: {	/* pragma_item :  PRAGMA_NOPUT */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr241: {	/* pragma_item :  PRAGMA_PUTXML */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr242: {	/* pragma_item :  PRAGMA_NOPUTXML */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr243: {	/* pragma_item :  PRAGMA_TRACE */
 yyval.lp = lnew0(yypvt[0].ival); if (!yyval.lp->included) decl_trace = 1; 
} break;

case YYr244: {	/* pragma_item :  PRAGMA_NOTRACE */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr245: {	/* pragma_item :  PRAGMA_LINE */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr246: {	/* pragma_item :  PRAGMA_NOLINE */
 yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr247: {	/* pragma_item :  PRAGMA_NULLSTRINGS */
 null_strings = 1; yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr248: {	/* pragma_item :  PRAGMA_NONULLSTRINGS */
 null_strings = 0; yyval.lp = lnew0(yypvt[0].ival); 
} break;

case YYr249: {	/* pragma_item :  PRAGMA_INCLUDES */
 yyval.lp = lnew0(yypvt[0].ival); if (!yyval.lp->included) gen_includes = 1; 
} break;

case YYr250: {	/* pragma_item :  PRAGMA_NOINCLUDES */
 yyval.lp = lnew0(yypvt[0].ival); if (!yyval.lp->included) gen_includes = 0; 
} break;

case YYr251: {	/* pragma_item :  PRAGMA_BITSTREAM '=' STRING_LITERAL */
 yyval.lp = lnew1(yypvt[-2].ival, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr252: {	/* pragma_item :  PRAGMA_PREFIX '=' STRING_LITERAL */
 yyval.lp = lnew1(yypvt[-2].ival, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr253: {	/* pragma_item :  PRAGMA_ERROR_FUNC '=' STRING_LITERAL */
 yyval.lp = lnew1(yypvt[-2].ival, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr254: {	/* pragma_item :  PRAGMA_TRACE_FUNC '=' STRING_LITERAL */
 yyval.lp = lnew1(yypvt[-2].ival, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr255: {	/* import_file :  IMPORT STRING_LITERAL */

        yyval.lp = lnew1(IMPORT, leafstr(STRING_LITERAL, yypvt[0].string));
        if (!include(yypvt[0].string, 1)) {
            
            if (w_includes) yyerror("Importing file '%s' would create an infinite loop", yypvt[0].string);
            yyval.lp = NULL;
        }
    
} break;

case YYr256: {	/* include_file :  INCLUDE STRING_LITERAL */

        yyval.lp = lnew1(yypvt[-1].ival, leafstr(STRING_LITERAL, gethname(yypvt[0].string)));
        if (!include(yypvt[0].string, 0)) {
            
            if (w_includes) yyerror("Including file '%s' would create an infinite loop", yypvt[0].string);
            yyval.lp = NULL;
        }
    
} break;

case YYr257: {	/* map_definition :  map_declarator map_body */

        s_set_cur_class(NULL);  
        yyval.lp = lnews_sp(MAP, yypvt[-1].sp, yypvt[0].lp);
    
} break;

case YYr258: {	/* map_declarator :  MAP identifier '(' type_specifier ')' */

        yypvt[-3].sp->ident = MAP_TYPE;
        yypvt[-3].sp->modifiers = M_NONE;
        yypvt[-3].sp->ptype = yypvt[-1].sp;
        if (yypvt[-1].sp->ident == CLASS_TYPE) check_map_class(yypvt[-1].sp);
        yyval.sp = s_set_cur_class(yypvt[-3].sp); 
    
} break;

case YYr259: {	/* map_declarator :  MAP identifier '(' declaration_modifiers ')' */

        yypvt[-3].sp->ident = MAP_TYPE;
        yypvt[-3].sp->modifiers = yypvt[-1].ival;
        yypvt[-3].sp->ptype = s_lookup("int");
        yyval.sp = s_set_cur_class(yypvt[-3].sp);
    
} break;

case YYr260: {	/* map_declarator :  MAP identifier '(' declaration_modifiers builtin_type_specifier ')' */

        yypvt[-4].sp->ident = MAP_TYPE;
        yypvt[-4].sp->modifiers = yypvt[-2].ival;
        yypvt[-4].sp->ptype = yypvt[-1].sp;
        yyval.sp = s_set_cur_class(yypvt[-4].sp);
    
} break;

case YYr261: {	/* map_body :  '{' map_entry_list '}' */
 yyval.lp = yypvt[-1].lp; 
} break;

case YYr263: {	/* map_entry_list :  map_entry_list ',' map_entry */
 
        
        if (check_map(s_get_cur_class(), yypvt[-2].lp, yypvt[0].lp)) yyval.lp = app_map(yypvt[-2].lp, yypvt[0].lp); 
        else yyval.lp = yypvt[-2].lp;
    
} break;

case YYr264: {	/* map_entry :  map_code ',' map_entry_item */
 yyval.lp = yypvt[-2].lp; yyval.lp->sub1 = yypvt[0].lp; 
} break;

case YYr265: {	/* map_code :  BIT_LITERAL */
 yyval.lp = lnew1(BIT_LITERAL, leafb(BIT_LITERAL, yypvt[0].bit)); 
} break;

case YYr266: {	/* map_entry_item_list :  conditional_expr */
 yyval.lp = lnew1(EXPR, yypvt[0].np); 
} break;

case YYr267: {	/* map_entry_item_list :  map_entry_item_list ',' conditional_expr */
 yyval.lp = app(yypvt[-2].lp, lnew1(EXPR, yypvt[0].np)); 
} break;

case YYr268: {	/* map_entry_item_escape :  builtin_type_specifier '(' conditional_expr ')' */
 
        yyval.lp = lnew3(ESC_FTYPE, leafi(EXPR, M_NONE), leafbs(EXPR, yypvt[-3].sp), yypvt[-1].np); 
    
} break;

case YYr269: {	/* map_entry_item_escape :  declaration_modifiers builtin_type_specifier '(' conditional_expr ')' */
 
        yyval.lp = lnew3(ESC_FTYPE, leafi(EXPR, check_modtype(yypvt[-4].ival, yypvt[-3].sp)), leafbs(EXPR, yypvt[-3].sp), yypvt[-1].np);       
    
} break;

case YYr270: {	/* map_entry_item_escape_list :  map_entry_item_escape */
 yyval.lp = yypvt[0].lp; 
} break;

case YYr271: {	/* map_entry_item_escape_list :  map_entry_item_escape_list ',' map_entry_item_escape */
 yyval.lp = app(yypvt[-2].lp, yypvt[0].lp); 
} break;

case YYr272: {	/* map_entry_item :  conditional_expr */
 yyval.lp = check_map_simple_value(s_get_cur_class(), lnew1(EXPR, yypvt[0].np)); 
} break;

case YYr273: {	/* map_entry_item :  '{' map_entry_item_list '}' */
 yyval.lp = check_map_class_value(s_get_cur_class(), lnews0(yypvt[-2].ival, yypvt[-1].lp)); 
} break;

case YYr274: {	/* map_entry_item :  map_entry_item_escape */

        check_map_esc_simple_value(s_get_cur_class(), yypvt[0].lp);
        if (s_get_cur_class()->escape == 1) {
            yyerror("Escape code is allowed only once in a map");
            exit(1);
        }
        s_get_cur_class()->escape = 1;
        yyval.lp = yypvt[0].lp;
    
} break;

case YYr275: {	/* map_entry_item :  '{' map_entry_item_escape_list '}' */
 
        check_map_esc_class_value(s_get_cur_class(), yypvt[-1].lp); 
        if (s_get_cur_class()->escape == 1) {
            yyerror("Escape code is allowed only once in a map");
            exit(1);
        }
        s_get_cur_class()->escape = 1;
        yyval.lp = yypvt[-1].lp;
    
} break;

case YYr276: {	/* map_entry_item :  STRING_LITERAL */

        
        yyval.lp = NULL;
    
} break;

case YYr277: {	/* bac_definition :  bac_declarator bac_body */

        s_set_cur_class(NULL);  
        yyval.lp = lnews_sp(BAC, yypvt[-1].sp, yypvt[0].lp);
    
} break;

case YYr278: {	/* bac_declarator :  BAC identifier */

        yypvt[0].sp->ident = BAC_TYPE;
        yypvt[0].sp->modifiers = M_NONE;
        yyval.sp = s_set_cur_class(yypvt[0].sp); 
    
} break;

case YYr279: {	/* bac_body :  '{' bac_entry_list '}' */
 yyval.lp = yypvt[-1].lp; 
} break;

case YYr281: {	/* bac_entry_list :  bac_entry_list ',' bac_entry */
 yyval.lp = app(yypvt[-2].lp, yypvt[0].lp); 
} break;

case YYr282: {	/* bac_entry :  bac_keyword ',' bac_entry_item */
 yyval.lp=yypvt[-2].lp; yyval.lp->sub1=yypvt[0].lp; check_bac_val(yyval.lp); 
} break;

case YYr283: {	/* bac_keyword :  STRING_LITERAL */
 yyval.lp = lnew1(INT_LITERAL, leafi(INT_LITERAL, check_bac_param(yypvt[0].string))); 
} break;

case YYr284: {	/* bac_entry_item :  conditional_expr */
 yyval.lp = lnew1(EXPR, yypvt[0].np); 
} break;

case YYr285: {	/* bac_entry_item :  STRING_LITERAL */
 yyval.lp = lnew1(STRING_LITERAL, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr286: {	/* bac_entry_item :  '{' bac_entry_item_list '}' */
 yyval.lp = lnews0(yypvt[-2].ival, yypvt[-1].lp); 
} break;

case YYr287: {	/* bac_entry_item_list :  conditional_expr */
 yyval.lp = lnew1(EXPR, yypvt[0].np); 
} break;

case YYr288: {	/* bac_entry_item_list :  STRING_LITERAL */
 yyval.lp = lnew1(STRING_LITERAL, leafstr(STRING_LITERAL, yypvt[0].string)); 
} break;

case YYr289: {	/* bac_entry_item_list :  bac_entry_item_list ',' conditional_expr */
 yyval.lp = app(yypvt[-2].lp, lnew1(EXPR, yypvt[0].np)); 
} break;

case YYr290: {	/* bac_entry_item_list :  bac_entry_item_list ',' STRING_LITERAL */
 yyval.lp = app(yypvt[-2].lp, lnew1(STRING_LITERAL, leafstr(STRING_LITERAL, yypvt[0].string))); 
} break;

case YYr291: {	/* bac_statement :  BAC_TYPE '(' INT_LITERAL ')' ';' */
 yyval.lp = lnew2(BAC_TYPE, leafs(BAC_TYPE, yypvt[-4].sp), leafi(INT_LITERAL, yypvt[-2].ival)); 
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}

	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)
		;

	yystate = ~(yyi == *--yyp? YYQYYP: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
/*
#pragma used yyerrlabel
 */
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--;
		yypv--;
#if YYDEBUG
		yytp--;
#endif
	}

yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > yys; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact)
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);

			if (YYERRCODE == yyp[-1]) {
				yystate = ~YYQYYP;
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > yys+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin;
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

#ifdef YYALLOC
yyReturn:
	yylval = save_yylval;
	yyval = save_yyval;
	yypvt = save_yypvt;
	yychar = save_yychar;
	yyerrflag = save_yyerrflag;
	yynerrs = save_yynerrs;
	free((char *)yys);
	free((char *)yyv);
#if YYDEBUG
	free((char *)yytypev);
#endif
	return(retval);
#endif
}

		
#if YYDEBUG
/*
 * Return type of token
 */
int
yyGetType(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}
/*
 * Print a token legibly.
 */
char *
yyptok(tok)
int tok;
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}

/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

static char *
yygetState(num)
int num;
{
	int	size;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(yyStates[num+1] - yyStates[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - yyStates[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, yyStates[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yyExpandName(num, isrule, buf, len)
int num, isrule;
char * buf;
int len;
{
	int	i, n, cnt, type;
	char	* endp, * cp;
	char	*s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yyShowState(tp)
yyTraceItems * tp;
{
	short * p;
	YYSTYPE * q;

	printf(
	    m_textmsg(2828, "state %d (%d), char %s (%d)\n", "I num1 num2 char num3"),
	      yysmap[tp->state], tp->state,
	      yyptok(tp->lookahead), tp->lookahead);
}
/*
 * show results of reduction
 */
void
yyShowReduce(tp)
yyTraceItems * tp;
{
	printf("reduce %d (%d), pops %d (%d)\n",
		yyrmap[tp->rule], tp->rule,
		tp->states[tp->nstates - tp->npop],
		yysmap[tp->states[tp->nstates - tp->npop]]);
}
void
yyShowRead(val)
int val;
{
	printf(m_textmsg(2829, "read %s (%d)\n", "I token num"), yyptok(val), val);
}
void
yyShowGoto(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2830, "goto %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowShift(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2831, "shift %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowErrRecovery(tp)
yyTraceItems * tp;
{
	short	* top = tp->states + tp->nstates - 1;

	printf(
	m_textmsg(2832, "Error recovery pops state %d (%d), uncovers %d (%d)\n", "I num1 num2 num3 num4"),
		yysmap[*top], *top, yysmap[*(top-1)], *(top-1));
}
void
yyShowErrDiscard(tp)
yyTraceItems * tp;
{
	printf(m_textmsg(2833, "Error recovery discards %s (%d), ", "I token num"),
		yyptok(tp->lookahead), tp->lookahead);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
